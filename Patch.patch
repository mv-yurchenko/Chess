Index: DebugOutput/print_possibilities.txt
===================================================================
--- DebugOutput/print_possibilities.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ DebugOutput/print_possibilities.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,80 +0,0 @@
-Possibility:
-Current coordinates : 0 1
-New coordinates : 0 2
-Weight: 0
-Possibility:
-Current coordinates : 0 1
-New coordinates : 0 3
-Weight: 0
-Possibility:
-Current coordinates : 1 0
-New coordinates : 2 2
-Weight: 0
-Possibility:
-Current coordinates : 1 0
-New coordinates : 0 2
-Weight: 0
-Possibility:
-Current coordinates : 1 1
-New coordinates : 1 2
-Weight: 0
-Possibility:
-Current coordinates : 1 1
-New coordinates : 1 3
-Weight: 0
-Possibility:
-Current coordinates : 2 1
-New coordinates : 2 2
-Weight: 0
-Possibility:
-Current coordinates : 2 1
-New coordinates : 2 3
-Weight: 0
-Possibility:
-Current coordinates : 3 1
-New coordinates : 3 2
-Weight: 0
-Possibility:
-Current coordinates : 3 1
-New coordinates : 3 3
-Weight: 0
-Possibility:
-Current coordinates : 4 1
-New coordinates : 4 2
-Weight: 0
-Possibility:
-Current coordinates : 4 1
-New coordinates : 4 3
-Weight: 0
-Possibility:
-Current coordinates : 5 1
-New coordinates : 5 2
-Weight: 0
-Possibility:
-Current coordinates : 5 1
-New coordinates : 5 3
-Weight: 0
-Possibility:
-Current coordinates : 6 0
-New coordinates : 7 2
-Weight: 0
-Possibility:
-Current coordinates : 6 0
-New coordinates : 5 2
-Weight: 0
-Possibility:
-Current coordinates : 6 1
-New coordinates : 6 2
-Weight: 0
-Possibility:
-Current coordinates : 6 1
-New coordinates : 6 3
-Weight: 0
-Possibility:
-Current coordinates : 7 1
-New coordinates : 7 2
-Weight: 0
-Possibility:
-Current coordinates : 7 1
-New coordinates : 7 3
-Weight: 0
Index: Engine/Engine.cpp
===================================================================
--- Engine/Engine.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Engine/Engine.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,74 +0,0 @@
-//
-// Created by max on 27.09.18.
-//
-
-#include <time.h>
-#include <algorithm>
-#include <random>
-#include "Engine.h"
-
-Engine::Engine(Desk *desk, bool is_move_white) {
-    this->current_desk = desk;
-    this->is_move_white = is_move_white;
-    if (is_move_white){
-        for (Figure figure : desk->getWhite_figures()){
-                add_possible_moves_to_possibilities(figure);
-        }
-    } else{
-        for (Figure figure : desk->getBlack_figures()){
-            add_possible_moves_to_possibilities(figure);
-        }
-    }
-    this->print_possibilities();
-}
-
-void Engine::print_possibilities() {
-    //////////////////////////////////////////
-    //  Дебаг функция
-    /////////////////////////////////////////
-    std::ofstream output_file;
-    output_file.open("../DebugOutput/print_possibilities.txt");
-    for (MoveWeight possibility : possibilities){
-        output_file << "Possibility:" << std::endl;
-        output_file << "Current coordinates : " << possibility.getMove().getOld_coordinates().getX() << " " <<
-                    possibility.getMove().getOld_coordinates().getY() << std::endl;
-        output_file << "New coordinates : " << possibility.getMove().getNew_coordinates().getX() << " " <<
-                    possibility.getMove().getNew_coordinates().getY() << std::endl;
-        output_file << "Weight: " << possibility.getWeight() << std::endl;
-        output_file << "----------------------------------------------------" << std::endl;
-    }
-}
-
-void Engine::add_possible_moves_to_possibilities(Figure figure) {
-    possibilities.clear();
-    for (auto possible_move : figure.getPossible_moves()){
-        MoveWeight possibility;
-        possibility.setMove(possible_move);
-        possibility.setWeight(this->current_desk->get_figure_by_coordinates(possible_move.getNew_coordinates())->getValue());
-        possibilities.push_back(possibility);
-    }
-}
-
-int Engine::get_random_num(int max_num) {
-    srand(static_cast<unsigned int>(time(nullptr)));
-    return rand() % max_num;
-}
-
-void Engine::search_max_possibility() {
-    for (auto possibility : possibilities) {
-        if (possibility.getWeight() > most_profitable_move.getWeight()) {
-            most_profitable_move = possibility;
-        }
-        if (possibility.getWeight() == most_profitable_move.getWeight() and
-            (20 + (rand() % static_cast<int>(100 - 20 + 1))) % 2) {
-            most_profitable_move = possibility;
-        }
-    }
-}
-
-Move Engine::move() {
-    search_max_possibility();
-    return most_profitable_move.getMove();
-}
-
-
Index: Engine/Engine.h
===================================================================
--- Engine/Engine.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Engine/Engine.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,37 +0,0 @@
-//
-// Created by max on 27.09.18.
-//
-
-#ifndef CHESS_ENGINE_H
-#define CHESS_ENGINE_H
-
-#include "../Desk.h"
-#include "MoveWeight.h"
-#include "cstdlib"
-#include <ctime>
-
-
-class Engine {
-    std::vector<MoveWeight> possibilities;
-    Desk *new_desk;
-    Desk *current_desk;
-    MoveWeight most_profitable_move;
-    bool is_move_white;
-public:
-    Engine() = default;
-
-    Engine(Desk *desk, bool is_move_white);
-
-    void add_possible_moves_to_possibilities(Figure figure);
-
-    void print_possibilities();
-
-    Move move();
-
-    void search_max_possibility();
-
-    int get_random_num(int max_num);
-};
-
-
-#endif //CHESS_ENGINE_H
Index: Engine/MoveWeight.cpp
===================================================================
--- Engine/MoveWeight.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Engine/MoveWeight.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,23 +0,0 @@
-//
-// Created by max on 26.09.18.
-//
-
-#include "MoveWeight.h"
-
-MoveWeight::MoveWeight(int weight, Move move) : weight(weight), move(move) {}
-
-const Move &MoveWeight::getMove() const {
-    return move;
-}
-
-int MoveWeight::getWeight() const {
-    return weight;
-}
-
-void MoveWeight::setMove(const Move &move) {
-    MoveWeight::move = move;
-}
-
-void MoveWeight::setWeight(int weight) {
-    MoveWeight::weight = weight;
-}
\ No newline at end of file
Index: Engine/MoveWeight.h
===================================================================
--- Engine/MoveWeight.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Engine/MoveWeight.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,32 +0,0 @@
-//
-// Created by max on 26.09.18.
-//
-
-#ifndef CHESS_MOVEWEIGHT_H
-#define CHESS_MOVEWEIGHT_H
-
-#include "../Move.h"
-
-class MoveWeight {
-private:
-    Move move;
-    int weight;
-
-public:
-    MoveWeight() = default;
-
-    MoveWeight(int weight, Move move);
-
-    const Move &getMove() const;
-
-    int getWeight() const;
-
-    void setMove(const Move &move);
-
-    void setWeight(int weight);
-
-
-};
-
-
-#endif //CHESS_MOVEWEIGHT_H
Index: Figures/Bishop.cpp
===================================================================
--- Figures/Bishop.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Bishop.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,81 +0,0 @@
-//
-// Created by Max Yurchenko on 02.09.2018.
-//
-
-#include "Bishop.h"
-
-Bishop::Bishop(bool side, Coordinates coordinates) : Figure(side, coordinates, "bishop", 3){
-    if (side){
-        setDesk_name("W_B");
-    } else{
-        setDesk_name("B_B");
-    }
-}
-
-void Bishop::calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) {
-
-        //  top right
-
-        calculate_one_direction(white_figures, black_figures, true, true);
-
-        //  top left
-
-        calculate_one_direction(white_figures, black_figures, true, false);
-
-        // bottom right
-
-        calculate_one_direction(white_figures, black_figures, false, true);
-
-        // bottom left
-
-        calculate_one_direction(white_figures, black_figures, false, false);
-
-}
-
-void Bishop::calculate_one_direction(const std::vector<Figure> &white_figures, const std::vector<Figure> &black_figures,
-                                     bool increment_up, bool increment_right) {
-
-    Coordinates new_coordinates(getCoordinates().getX(), getCoordinates().getY());
-    bool is_way_free = true;
-    bool is_not_out_of_border = true;
-
-    std::vector<Figure> allies_figure;
-    std::vector<Figure> enemy_figures;
-
-    if (getSide()){
-        allies_figure = white_figures;
-        enemy_figures = black_figures;
-    } else{
-        allies_figure = black_figures;
-        enemy_figures = white_figures;
-    }
-    for(uint8_t i = 1; i < 8; i++) {
-        if (is_way_free and is_not_out_of_border) {
-            bool is_move_possible = true;
-            if (increment_right)
-                new_coordinates.setX(getCoordinates().getX() + i);
-            else
-                new_coordinates.setX(getCoordinates().getX() - i);
-            if (increment_up)
-                new_coordinates.setY(getCoordinates().getY() + i);
-            else
-                new_coordinates.setY(getCoordinates().getY() - i);
-            if (is_out_of_border(new_coordinates)) {
-                is_not_out_of_border = false;
-            } else {
-                if (is_cell_busy_by_enemy_figure(new_coordinates, enemy_figures)){
-                    add_move_to_possible_moves(new_coordinates);
-                    is_way_free = false;
-                }
-                if (is_cell_busy_by_ally_figure(new_coordinates, allies_figure)){
-                    is_way_free = false;
-                    is_move_possible = false;
-                }
-                if (is_move_possible)
-                    add_move_to_possible_moves(new_coordinates);
-            }
-        }
-    }
-}
-
-
Index: Figures/Bishop.h
===================================================================
--- Figures/Bishop.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Bishop.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,23 +0,0 @@
-//
-// Created by Max Yurchenko on 02.09.2018.
-//
-
-#ifndef CHESS_BISHOP_H
-#define CHESS_BISHOP_H
-
-
-#include "Figure.h"
-
-class Bishop : public Figure{
-
-public:
-
-    Bishop(bool side, Coordinates coordinates);
-
-    void calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) override;
-
-    void calculate_one_direction(const std::vector<Figure> &white_figures, const std::vector <Figure> &black_figures, bool increment_up , bool increment_right);
-};
-
-
-#endif //CHESS_BISHOP_H
Index: Figures/Castle.cpp
===================================================================
--- Figures/Castle.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Castle.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,73 +0,0 @@
-//
-// Created by Max Yurchenko on 30.08.2018.
-//
-
-#include "Castle.h"
-
-Castle::Castle(bool side, Coordinates coordinates) : Figure(side, coordinates, "castle", 1){
-    this->setName("castle");
-    if (side){
-        setDesk_name("W_C");
-    } else{
-        setDesk_name("B_C");
-    }
-}
-
-void Castle::calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) {
-
-    calculate_one_direction(white_figures, black_figures, true, false, false, false);
-
-    calculate_one_direction(white_figures, black_figures, false, true, false, false);
-
-    calculate_one_direction(white_figures, black_figures, false, false, true, false);
-
-    calculate_one_direction(white_figures, black_figures, false, false, false, true);
-}
-
-void Castle::calculate_one_direction(const std::vector<Figure> &white_figures, const std::vector<Figure> &black_figures,
-                                     bool increment_up, bool increment_down, bool increment_right, bool increment_left) {
-
-    Coordinates new_coordinates(getCoordinates().getX(), getCoordinates().getY());
-    bool is_way_free = true;
-    bool is_not_out_of_border = true;
-
-    std::vector<Figure> allies_figure;
-    std::vector<Figure> enemy_figures;
-
-    if (getSide()){
-        allies_figure = white_figures;
-        enemy_figures = black_figures;
-    } else{
-        allies_figure = black_figures;
-        enemy_figures = white_figures;
-    }
-    for(uint8_t i = 1; i < 8; i++) {
-        if (is_way_free and is_not_out_of_border) {
-            bool is_move_possible = true;
-            if (increment_right)
-                new_coordinates.setX(getCoordinates().getX() + i);
-            if (increment_left)
-                new_coordinates.setX(getCoordinates().getX() - i);
-            if (increment_down)
-                new_coordinates.setY(getCoordinates().getY() + i);
-            if (increment_up)
-                new_coordinates.setY(getCoordinates().getY() - i);
-            if (is_out_of_border(new_coordinates)) {
-                is_not_out_of_border = false;
-            } else {
-                if (is_cell_busy_by_enemy_figure(new_coordinates, enemy_figures)){
-                    add_move_to_possible_moves(new_coordinates);
-                    is_way_free = false;
-                }
-                if (is_cell_busy_by_ally_figure(new_coordinates, allies_figure)){
-                    is_way_free = false;
-                    is_move_possible = false;
-                }
-                if (is_move_possible)
-                    add_move_to_possible_moves(new_coordinates);
-            }
-        }
-    }
-}
-
-
Index: Figures/Castle.h
===================================================================
--- Figures/Castle.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Castle.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,25 +0,0 @@
-//
-// Created by Max Yurchenko on 30.08.2018.
-//
-
-#ifndef CHESS_CASTLE_H
-#define CHESS_CASTLE_H
-
-
-#include "Figure.h"
-
-
-class Castle : public Figure{
-
-public:
-
-    Castle(bool side, Coordinates coordinates);
-
-    void calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) override;
-
-    void calculate_one_direction(const std::vector<Figure> &white_figures, const std::vector<Figure> &black_figures,
-                                         bool increment_up,bool increment_down,bool increment_right, bool increment_left);
-};
-
-
-#endif //CHESS_CASTLE_H
Index: Figures/Figure.cpp
===================================================================
--- Figures/Figure.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Figure.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,167 +0,0 @@
-//
-// Created by Max Yurchenko on 24.08.2018.
-//
-
-#include "Figure.h"
-
-Figure::Figure(bool side, const Coordinates &coordinates, const char *name, int value) {
-    this->side = side;
-    this->coordinates = coordinates;
-    this->name = name;
-    this->value = value;
-    this->is_dead = false;
-}
-
-void Figure::calculate_possible_moves(std::vector<Figure> white_figures ,std::vector<Figure> black_figures ) {
-
-}
-
-const Coordinates &Figure::getCoordinates() const {
-    return coordinates;
-}
-
-const std::vector<Move> &Figure::getAvailable_moves() const {
-    return available_moves;
-}
-
-const std::vector<Move> &Figure::getPossible_moves() const {
-    return possible_moves;
-}
-
-const std::string &Figure::getName() const {
-    return name;
-}
-
-bool Figure::is_out_of_border(Coordinates coordinates) {
-    return  coordinates.getX() >= 8 or coordinates.getX() < 0 or coordinates.getY() >= 8 or coordinates.getY() < 0;
-}
-
-Figure::Figure() {
-    this->name = "NoFigure";
-    this->side = NULL;
-    this->setValue(0);
-}
-
-void Figure::setCoordinates(const Coordinates &coordinates) {
-    this->coordinates = coordinates;
-}
-
-bool Figure::is_coordinates_same(Coordinates coordinates1, Coordinates coordinates2) {
-    return coordinates1.getX() == coordinates2.getX() and coordinates2.getY() == coordinates1.getY();
-}
-
-bool Figure::is_figure_white() {
-    return this->side;
-}
-
-bool Figure::is_figure_black() {
-    return not this->side;
-}
-
-void Figure::print_possible_moves() {
-    //////////////////////////////////////////
-    //  Дебаг функция
-    /////////////////////////////////////////
-    std::cout << "POSSIBLE MOVES" << std::endl;
-    for (auto move : this->getPossible_moves()){
-        std::cout << "Possible move" << std::endl;
-        std::cout << move.getNew_coordinates().getX() << std::endl;
-        std::cout << move.getNew_coordinates().getY() << std::endl;
-        std::cout << "--------------------------" << std::endl;
-    }
-}
-
-void Figure::print_available_moves() {
-    //////////////////////////////////////////
-    //  Дебаг функция
-    /////////////////////////////////////////
-    for (auto move : this->getAvailable_moves()){
-        std::cout << "New coordinates" << std::endl;
-        std::cout << move.getNew_coordinates().getX() << std::endl;
-        std::cout << move.getNew_coordinates().getY() << std::endl;
-        std::cout << "------------------------" << std::endl;
-    }
-}
-
-Figure::Figure(bool side, Coordinates coordinates) {
-    this->side = side;
-    this->coordinates = coordinates;
-    this->is_dead = false;
-}
-
-void Figure::setName(const std::string &name) {
-    Figure::name = name;
-}
-
-void Figure::setSide(bool side) {
-    Figure::side = side;
-}
-
-void Figure::add_move_to_possible_moves(Coordinates new_coordinates) {
-    Move available_move(this->getCoordinates(), new_coordinates);
-    this->possible_moves.push_back(available_move);
-}
-
-bool Figure::is_cell_busy_by_enemy_figure(Coordinates cell, std::vector<Figure> enemy_figures) {
-    for (const auto &figure : enemy_figures){
-        if (is_coordinates_same(cell, figure.getCoordinates())){
-            return true;
-        }
-    }
-    return false;
-}
-
-bool Figure::is_cell_busy_by_ally_figure(Coordinates cell, std::vector<Figure> ally_figures) {
-    for (const auto &figure : ally_figures){
-        if (is_coordinates_same(cell, figure.getCoordinates())){
-            return true;
-        }
-    }
-    return false;
-}
-
-bool Figure::getSide() const {
-    return side;
-}
-
-void Figure::setValue(int value) {
-    Figure::value = value;
-}
-
-void Figure::clear_possible_moves() {
-    this->possible_moves.clear();
-}
-
-const char *Figure::get_side_as_string() {
-    if (getSide()){
-        return "White";
-    } else{
-        return "Black";
-    }
-}
-
-void Figure::setDesk_name(const char *desk_name) {
-    Figure::desk_name = desk_name;
-}
-
-const std::string &Figure::getDesk_name() const {
-    return desk_name;
-}
-
-bool Figure::is_cell_empty(Coordinates cell, std::vector<Figure> white_figures, std::vector<Figure> black_figures) {
-    for (const auto &figure : white_figures){
-        if (is_coordinates_same(cell, figure.getCoordinates())){
-            return false;
-        }
-    }
-    for (const auto &figure : black_figures){
-        if (is_coordinates_same(cell, figure.getCoordinates())){
-            return false;
-        }
-    }
-    return true;
-}
-
-int Figure::getValue() const {
-    return value;
-}
Index: Figures/Figure.h
===================================================================
--- Figures/Figure.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Figure.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,88 +0,0 @@
-//
-// Created by Max Yurchenko on 24.08.2018.
-//
-
-// TODO: Удалить available_moves
-
-#ifndef CHESS_FIGURE_H
-#define CHESS_FIGURE_H
-
-#include "../Move.h"
-#include <iostream>
-#include <vector>
-#include <string>
-
-class Figure  {
-    bool side;
-    int value;
-public:
-    int getValue() const;
-
-public:
-    void setValue(int value);
-
-private:
-    Coordinates coordinates;
-    std::vector <Move> available_moves;
-    std::vector <Move> possible_moves;
-    std::string name;
-    std::string desk_name;
-public:
-    const std::string &getDesk_name() const;
-
-public:
-    void setDesk_name(const char *desk_name);
-
-private:
-    bool is_dead = false;
-public:
-    void setName(const std::string &name);
-
-    void setCoordinates(const Coordinates &coordinates);
-
-    Figure(bool side, const Coordinates &coordinates, const char *name, int value);
-
-    Figure(bool side, Coordinates coordinates);
-
-    Figure();
-
-    virtual void calculate_possible_moves(std::vector<Figure> white_figures ,std::vector<Figure> black_figures );
-
-    const Coordinates &getCoordinates() const;
-
-    const std::vector<Move> &getAvailable_moves() const;
-
-    const std::vector<Move> &getPossible_moves() const;
-
-    const std::string &getName() const;
-
-    bool is_out_of_border(Coordinates coordinates);
-
-    void add_move_to_possible_moves(Coordinates new_coordinates);
-
-    bool is_coordinates_same(Coordinates coordinates1, Coordinates coordinates2);
-
-    bool is_figure_white();
-
-    bool is_figure_black();
-
-    void print_possible_moves();
-
-    void print_available_moves();
-
-    void setSide(bool side);
-
-    bool is_cell_busy_by_enemy_figure(Coordinates cell, std::vector<Figure> enemy_figures);
-
-    bool is_cell_busy_by_ally_figure(Coordinates cell, std::vector<Figure> ally_figures);
-
-    bool is_cell_empty(Coordinates cell, std::vector<Figure> white_figures, std::vector<Figure> black_figures);
-
-    bool getSide() const;
-
-    void clear_possible_moves();
-
-    const char *get_side_as_string();
-};
-
-#endif //CHESS_FIGURE_H
\ No newline at end of file
Index: Figures/King.cpp
===================================================================
--- Figures/King.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/King.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,55 +0,0 @@
-//
-// Created by Max Yurchenko on 25.08.2018.
-//
-
-#include "King.h"
-
-King::King() = default;
-
-void King::calculate_possible_moves(std::vector<Figure> white_figures ,std::vector<Figure> black_figures ) {
-    std::vector<Figure> ally_figures;
-    if (is_figure_white()){
-        ally_figures = white_figures;
-    } else{
-        ally_figures = black_figures;
-    }
-
-    calculate_one_direction(ally_figures, true, false, false, false);
-    calculate_one_direction(ally_figures, false, true, false, false);
-    calculate_one_direction(ally_figures, false, false , true, false);
-    calculate_one_direction(ally_figures, false, false , false, true);
-
-    calculate_one_direction(ally_figures, true, false, true, false);
-    calculate_one_direction(ally_figures, true, false, false, true);
-    calculate_one_direction(ally_figures, false, true, false, true);
-    calculate_one_direction(ally_figures, false, true, true, false);
-
-}
-
-King::King(bool side, Coordinates coordinates) : Figure(side, coordinates ,"king", 9999){
-    if (side){
-        setDesk_name("W_K");
-    } else{
-        setDesk_name("B_K");
-    }
-}
-
-void King::calculate_one_direction(const std::vector<Figure> &ally_figures, bool up, bool down, bool right, bool left) {
-    Coordinates new_coordinates(getCoordinates().getX(), getCoordinates().getY());
-
-    if (up) {
-        new_coordinates.setY(getCoordinates().getY() + 1);
-    }
-    if (down) {
-        new_coordinates.setY(getCoordinates().getY() - 1);
-    }
-    if (right){
-        new_coordinates.setX(getCoordinates().getX() + 1);
-    }
-    if (left){
-        new_coordinates.setX(getCoordinates().getX() - 1);
-    }
-    if (not is_out_of_border(new_coordinates) and not is_cell_busy_by_ally_figure(new_coordinates, ally_figures)) {
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
Index: Figures/King.h
===================================================================
--- Figures/King.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/King.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,24 +0,0 @@
-//
-// Created by Max Yurchenko on 25.08.2018.
-//
-
-
-#ifndef CHESS_KING_H
-#define CHESS_KING_H
-
-#include "Figure.h"
-#include <string>
-
-class King : public Figure{
-public:
-    King();
-
-    King(bool side, Coordinates coordinates);
-
-    void calculate_possible_moves(std::vector<Figure> white_figures ,std::vector<Figure> black_figures) override;
-
-    void calculate_one_direction(const std::vector<Figure> &ally_figures, bool up, bool down, bool right, bool left);
-};
-
-
-#endif //CHESS_KING_H
Index: Figures/Knight.cpp
===================================================================
--- Figures/Knight.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Knight.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,100 +0,0 @@
-//
-// Created by Max Yurchenko on 29.08.2018.
-//
-
-#include "Knight.h"
-
-Knight::Knight(bool side, Coordinates coordinates) {
-    this->setName("Knight");
-    this->setSide(side);
-    this->setCoordinates(coordinates);
-    this->setValue(3);
-    if (side){
-        setDesk_name("W_Kn");
-    } else{
-        setDesk_name("B_Kn");
-    }
-}
-
-Knight::Knight() {
-
-}
-
-void Knight::calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) {
-    std::vector<Figure> ally_figures;
-    std::vector<Figure> enemy_figures;
-    if (is_figure_white()) {
-        ally_figures = white_figures;
-        enemy_figures = black_figures;
-    } else{
-        ally_figures = black_figures;
-        enemy_figures = white_figures;
-    }
-
-    calculate_move_possibility_2_right_1_down(ally_figures);
-    calculate_move_possibility_2_right_1_up(ally_figures);
-    calculate_move_possibility_2_up_1_right(ally_figures);
-    calculate_move_possibility_2_up_1_left(ally_figures);
-    calculate_move_possibility_2_left_1_up(ally_figures);
-    calculate_move_possibility_2_left_1_down(ally_figures);
-    calculate_move_possibility_2_down_1_left(ally_figures);
-    calculate_move_possibility_2_down_1_right(ally_figures);
-}
-
-void Knight::calculate_move_possibility_2_down_1_right(std::vector<Figure> ally_figures) {
-    Coordinates new_coordinates(getCoordinates().getX() + 1, getCoordinates().getY() - 2);
-    if (not is_out_of_border(new_coordinates) and not is_cell_busy_by_ally_figure(new_coordinates, ally_figures)){
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
-
-void Knight::calculate_move_possibility_2_down_1_left(std::vector<Figure> ally_figures) {
-    Coordinates new_coordinates(getCoordinates().getX() - 1, getCoordinates().getY() - 2);
-    if (not is_out_of_border(new_coordinates) and not is_cell_busy_by_ally_figure(new_coordinates, ally_figures)){
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
-
-void Knight::calculate_move_possibility_2_left_1_down(std::vector<Figure> ally_figures) {
-    Coordinates new_coordinates(getCoordinates().getX() - 2, getCoordinates().getY() - 1);
-    if (not is_out_of_border(new_coordinates) and not is_cell_busy_by_ally_figure(new_coordinates, ally_figures)){
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
-
-void Knight::calculate_move_possibility_2_left_1_up(std::vector<Figure> ally_figures) {
-    Coordinates new_coordinates(getCoordinates().getX() - 2, getCoordinates().getY() + 1);
-    if (not is_out_of_border(new_coordinates) and not is_cell_busy_by_ally_figure(new_coordinates, ally_figures)){
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
-
-void Knight::calculate_move_possibility_2_up_1_left(std::vector<Figure> ally_figures) {
-    Coordinates new_coordinates(getCoordinates().getX() - 1, getCoordinates().getY() + 2);
-    if (not is_out_of_border(new_coordinates) and not is_cell_busy_by_ally_figure(new_coordinates, ally_figures)){
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
-
-void Knight::calculate_move_possibility_2_up_1_right(std::vector<Figure> ally_figures) {
-    Coordinates new_coordinates(getCoordinates().getX() + 1, getCoordinates().getY() + 2);
-    if (not is_out_of_border(new_coordinates) and not is_cell_busy_by_ally_figure(new_coordinates, ally_figures)){
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
-
-void Knight::calculate_move_possibility_2_right_1_up(std::vector<Figure> ally_figures) {
-    Coordinates new_coordinates(getCoordinates().getX() + 2, getCoordinates().getY() + 1);
-    if (not is_out_of_border(new_coordinates) and not is_cell_busy_by_ally_figure(new_coordinates, ally_figures)){
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
-
-void Knight::calculate_move_possibility_2_right_1_down(std::vector<Figure> ally_figures) {
-    Coordinates new_coordinates(getCoordinates().getX() + 2, getCoordinates().getY() -1);
-    if (not is_out_of_border(new_coordinates) and not is_cell_busy_by_ally_figure(new_coordinates, ally_figures)){
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
-
-
Index: Figures/Knight.h
===================================================================
--- Figures/Knight.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Knight.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,38 +0,0 @@
-//
-// Created by Max Yurchenko on 29.08.2018.
-//
-
-#ifndef CHESS_KNIGHT_H
-#define CHESS_KNIGHT_H
-
-
-#include "Figure.h"
-
-class Knight : public Figure{
-public:
-    Knight(bool side, Coordinates coordinates);
-
-    Knight();
-
-    void calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) override;
-
-    void calculate_move_possibility_2_right_1_down(std::vector<Figure> ally_figures);
-
-    void calculate_move_possibility_2_right_1_up(std::vector<Figure> ally_figures);
-
-    void calculate_move_possibility_2_up_1_right(std::vector<Figure> ally_figures);
-
-    void calculate_move_possibility_2_up_1_left(std::vector<Figure> ally_figures);
-
-    void calculate_move_possibility_2_left_1_up(std::vector<Figure> ally_figures);
-
-    void calculate_move_possibility_2_left_1_down(std::vector<Figure> ally_figures);
-
-    void calculate_move_possibility_2_down_1_left(std::vector<Figure> ally_figures);
-
-    void calculate_move_possibility_2_down_1_right(std::vector<Figure> ally_figures);
-
-};
-
-
-#endif //CHESS_KNIGHT_H
Index: Figures/Pawn.cpp
===================================================================
--- Figures/Pawn.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Pawn.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,105 +0,0 @@
-//
-// Created by Max Yurchenko on 27.08.2018.
-//
-
-#include "Pawn.h"
-
-Pawn::Pawn(bool side, Coordinates coordinates, int num){
-    this->setName("Pawn" + std::to_string(num));
-    this->setSide(side);
-    this->setCoordinates(coordinates);
-    this->setValue(1);
-    if (side){
-        setDesk_name("W_P");
-    } else{
-        setDesk_name("B_P");
-    }
-}
-
-Pawn::Pawn() {
-
-}
-
-void Pawn::calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) {
-    calculate_move_forward_possibility(white_figures, black_figures);
-
-    calculate_two_cell_move_possibility(white_figures, black_figures);
-
-    calculate_diagonal_move_possibility(white_figures, black_figures);
-}
-
-void Pawn::calculate_two_cell_move_possibility(std::vector<Figure> white_figures, std::vector<Figure> black_figures) {
-    bool two_cell_move_possible = true;
-    Coordinates new_coordinates{};
-    new_coordinates.setX(getCoordinates().getX());
-
-    if (is_figure_white()){
-        if (getCoordinates().getY() != 1){
-            two_cell_move_possible = false;
-        } else{
-            // Первая клетка
-            new_coordinates.setY(getCoordinates().getY() + 1);
-            if (not is_out_of_border(new_coordinates) and
-                is_cell_empty(new_coordinates, white_figures, black_figures)) {
-                new_coordinates.setY(getCoordinates().getY() + 2);
-                if(not is_out_of_border(new_coordinates) and
-                   is_cell_empty(new_coordinates, white_figures, black_figures)) {
-                    add_move_to_possible_moves(new_coordinates);
-                }
-            }
-        }
-    }else{
-        if (getCoordinates().getY() != 6){
-            two_cell_move_possible = false;
-        } else{
-            // Первая клетка
-            new_coordinates.setY(getCoordinates().getY() - 1);
-            if (not is_out_of_border(new_coordinates) and
-                is_cell_empty(new_coordinates, white_figures, black_figures)) {
-                new_coordinates.setY(getCoordinates().getY() - 2);
-                if (not is_out_of_border(new_coordinates) and
-                    is_cell_empty(new_coordinates, white_figures, black_figures)) {
-                    add_move_to_possible_moves(new_coordinates);
-                }
-            }
-        }
-    }
-}
-
-void Pawn::calculate_move_forward_possibility(std::vector<Figure> white_figures, std::vector<Figure> black_figures) {
-    Coordinates new_coordinates;
-    new_coordinates.setX(getCoordinates().getX());
-    if (is_figure_white()){
-        new_coordinates.setY(getCoordinates().getY() + 1);
-    }
-    else{
-        new_coordinates.setY(getCoordinates().getY() - 1);
-    }
-
-    if (not is_out_of_border(new_coordinates) and
-        not is_cell_busy_by_ally_figure(new_coordinates, white_figures) and
-        not is_cell_busy_by_ally_figure(new_coordinates, black_figures)){
-        add_move_to_possible_moves(new_coordinates);
-    }
-}
-
-void Pawn::calculate_diagonal_move_possibility(std::vector<Figure> white_figures, std::vector<Figure> black_figures) {
-    Coordinates new_coordinates;
-    if(is_figure_white()){
-        for (int i = 0 ; i < 2; i++) {
-            new_coordinates.setY(getCoordinates().getY() + 1);
-            new_coordinates.setX(getCoordinates().getX() + (-1)^i);
-            if (is_cell_busy_by_enemy_figure(new_coordinates, black_figures)) {
-                add_move_to_possible_moves(new_coordinates);
-            }
-        }
-    } else{
-        for (int i = 0 ; i < 2; i++) {
-            new_coordinates.setY(getCoordinates().getY() - 1);
-            new_coordinates.setX(getCoordinates().getX() + (-1)^i);
-            if (is_cell_busy_by_enemy_figure(new_coordinates, white_figures)) {
-                add_move_to_possible_moves(new_coordinates);
-            }
-        }
-    }
-}
Index: Figures/Pawn.h
===================================================================
--- Figures/Pawn.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Pawn.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,28 +0,0 @@
-//
-// Created by Max Yurchenko on 27.08.2018.
-//
-
-#ifndef CHESS_PAWN_H
-#define CHESS_PAWN_H
-
-
-#include "Figure.h"
-
-
-class Pawn : public Figure {
-public:
-    Pawn();
-
-    Pawn(bool side, Coordinates coordinates, int num);
-
-    void calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) override;
-
-    void calculate_move_forward_possibility(std::vector<Figure> white_figures, std::vector<Figure> black_figures);
-
-    void calculate_two_cell_move_possibility(std::vector<Figure> white_figures, std::vector<Figure> black_figures);
-
-    void calculate_diagonal_move_possibility(std::vector<Figure> white_figures, std::vector<Figure> black_figures);
-};
-
-
-#endif //CHESS_PAWN_H
Index: Figures/Queen.cpp
===================================================================
--- Figures/Queen.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Queen.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,137 +0,0 @@
-//
-// Created by Max Yurchenko on 03.09.2018.
-//
-
-#include "Queen.h"
-
-Queen::Queen(bool side, Coordinates coordinates) : Figure(side, coordinates, "queen", 9){
-    if (side){
-        setDesk_name("W_Q");
-    } else{
-        setDesk_name("B_Q");
-    }
-}
-
-Queen::Queen() {
-
-}
-
-void Queen::calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) {
-    //  top right
-
-    calculate_bishop_one_direction(white_figures, black_figures, true, true);
-
-    //  top left
-
-    calculate_bishop_one_direction(white_figures, black_figures, true, false);
-
-    // bottom right
-
-    calculate_bishop_one_direction(white_figures, black_figures, false, true);
-
-    // bottom left
-
-    calculate_bishop_one_direction(white_figures, black_figures, false, false);
-
-    calculate_castle_one_direction(white_figures, black_figures, true, false, false, false);
-
-    calculate_castle_one_direction(white_figures, black_figures, false, true, false, false);
-
-    calculate_castle_one_direction(white_figures, black_figures, false, false, false, true);
-
-    calculate_castle_one_direction(white_figures, black_figures, false, false, false, true);
-}
-
-void Queen::calculate_bishop_one_direction(const std::vector<Figure> &white_figures,
-                                           const std::vector<Figure> &black_figures, bool increment_up,
-                                           bool increment_right) {
-
-    Coordinates new_coordinates(getCoordinates().getX(), getCoordinates().getY());
-    bool is_way_free = true;
-    bool is_not_out_of_border = true;
-
-    std::vector<Figure> allies_figure;
-    std::vector<Figure> enemy_figures;
-
-    if (getSide()){
-        allies_figure = white_figures;
-        enemy_figures = black_figures;
-    } else{
-        allies_figure = black_figures;
-        enemy_figures = white_figures;
-    }
-    for(uint8_t i = 1; i < 8; i++) {
-        if (is_way_free and is_not_out_of_border) {
-            bool is_move_possible = true;
-            if (increment_right)
-                new_coordinates.setX(getCoordinates().getX() + i);
-            else
-                new_coordinates.setX(getCoordinates().getX() - i);
-            if (increment_up)
-                new_coordinates.setY(getCoordinates().getY() + i);
-            else
-                new_coordinates.setY(getCoordinates().getY() - i);
-            if (is_out_of_border(new_coordinates)) {
-                is_not_out_of_border = false;
-            } else {
-                if (is_cell_busy_by_enemy_figure(new_coordinates, enemy_figures)){
-                    add_move_to_possible_moves(new_coordinates);
-                    is_way_free = false;
-                }
-                if (is_cell_busy_by_ally_figure(new_coordinates, allies_figure)){
-                    is_way_free = false;
-                    is_move_possible = false;
-                }
-                if (is_move_possible)
-                    add_move_to_possible_moves(new_coordinates);
-            }
-        }
-    }
-}
-
-void Queen::calculate_castle_one_direction(const std::vector<Figure> &white_figures,
-                                           const std::vector<Figure> &black_figures, bool increment_up,
-                                           bool increment_down, bool increment_right, bool increment_left) {
-
-    Coordinates new_coordinates(getCoordinates().getX(), getCoordinates().getY());
-    bool is_way_free = true;
-    bool is_not_out_of_border = true;
-
-    std::vector<Figure> allies_figure;
-    std::vector<Figure> enemy_figures;
-
-    if (getSide()){
-        allies_figure = white_figures;
-        enemy_figures = black_figures;
-    } else{
-        allies_figure = black_figures;
-        enemy_figures = white_figures;
-    }
-    for(uint8_t i = 1; i < 8; i++) {
-        if (is_way_free and is_not_out_of_border) {
-            bool is_move_possible = true;
-            if (increment_right)
-                new_coordinates.setX(getCoordinates().getX() + i);
-            if (increment_left)
-                new_coordinates.setX(getCoordinates().getX() - i);
-            if (increment_down)
-                new_coordinates.setY(getCoordinates().getY() + i);
-            if (increment_up)
-                new_coordinates.setY(getCoordinates().getY() - i);
-            if (is_out_of_border(new_coordinates)) {
-                is_not_out_of_border = false;
-            } else {
-                if (is_cell_busy_by_enemy_figure(new_coordinates, enemy_figures)){
-                    add_move_to_possible_moves(new_coordinates);
-                    is_way_free = false;
-                }
-                if (is_cell_busy_by_ally_figure(new_coordinates, allies_figure)){
-                    is_way_free = false;
-                    is_move_possible = false;
-                }
-                if (is_move_possible)
-                    add_move_to_possible_moves(new_coordinates);
-            }
-        }
-    }
-}
Index: Figures/Queen.h
===================================================================
--- Figures/Queen.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Figures/Queen.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,29 +0,0 @@
-//
-// Created by Max Yurchenko on 03.09.2018.
-//
-
-#ifndef CHESS_QUEEN_H
-#define CHESS_QUEEN_H
-
-
-#include "Figure.h"
-
-class Queen : public Figure{
-
-public:
-
-    Queen(bool side, Coordinates coordinates);
-
-    Queen();
-
-    void calculate_possible_moves(std::vector<Figure> white_figures, std::vector<Figure> black_figures) override;
-
-    void calculate_bishop_one_direction(const std::vector<Figure> &white_figures, const std::vector<Figure> &black_figures,
-                                 bool increment_up, bool increment_right);
-
-    void calculate_castle_one_direction(const std::vector<Figure> &white_figures, const std::vector<Figure> &black_figures,
-                                 bool increment_up, bool increment_down, bool increment_right, bool increment_left);
-};
-
-
-#endif //CHESS_QUEEN_H
Index: Game/Game.cpp
===================================================================
--- Game/Game.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Game/Game.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,170 +0,0 @@
-//
-// Created by Max Yurchenko on 05.09.2018.
-//
-
-#include "Game.h"
-
-void Game::initialize_game() {
-    this->current_desk = new Desk();
-    this->is_game_finished = false;
-    this->white_turn = true;
-    current_desk->initialize_desk();
-}
-
-bool Game::move_figure(int old_x, int old_y, int new_x, int new_y) {
-    Coordinates old_coord(old_x, old_y);
-    Coordinates new_coord(new_x, new_y);
-//        this->current_desk->get_figure_by_coordinates(old_x, old_y)->print_possible_moves();
-    bool is_move_done = this->current_desk->move_figure(old_coord, new_coord);
-    return is_move_done;
-}
-
-Desk *Game::getCurrent_desk() const {
-    return current_desk;
-}
-
-bool Game::get_is_game_finished() const {
-    return is_game_finished;
-}
-
-bool Game::isWhite_turn() const {
-    return white_turn;
-}
-
-void Game::finish_game() {
-    is_game_finished = true;
-}
-
-int Game::input_coordinate(const char *coord_name) {
-    std::cout<<coord_name << std::endl;
-    int coord;
-    std::cin >> coord;
-    return coord - 1;
-}
-
-bool Game::is_mate(int x, int y) {
-    return this->getCurrent_desk()->get_figure_by_coordinates(x, y)->getName() == "king" and this->getCurrent_desk()->get_figure_by_coordinates(x, y)->getSide() == isWhite_turn();
-}
-
-bool Game::player_turn(bool is_white_turn) {
-
-}
-
-void Game::print_msg_about_success_move(int old_x, int old_y, int new_x, int new_y) {
-    std::cout << "Figure " << this->current_desk->get_figure_by_coordinates(new_x, new_y)->getName() << " was moved from : (" << old_x << " , " << old_y << ") to (" << new_x << " , " << new_y << ")"<< std::endl;
-}
-
-void Game::print_msg_about_failed_move(int old_x, int old_y, int new_x, int new_y) {
-    std::cout << "Figure " << this->current_desk->get_figure_by_coordinates(old_x, old_y)->getName() << " was NOT moved from : (" << old_x << " , " << old_y << ") to (" << new_x << " , " << new_y << ")"<< std::endl;
-}
-
-void Game::setIs_game_finished(bool is_game_finished) {
-    Game::is_game_finished = is_game_finished;
-}
-
-void Game::setWhite_turn(bool white_turn) {
-    Game::white_turn = white_turn;
-}
-
-void Game::write_log_about_move(Figure *figure, int old_x, int old_y, int new_x, int new_y) {
-    gameLogsWriter.write_log_about_move(figure, old_x, old_y, new_x, new_y);
-}
-
-void Game::print_request_to_move_again() {
-    std::cout << "Move FAILED" << std::endl << "Try again: " << std::endl;
-}
-
-Coordinates Game::input_coordinates() {
-    int first_num;
-    bool success_input = false;
-    std::string coordinates;
-    while (not success_input)
-    {
-        std::cout << "Input Coordinates:";
-        std::cin >> coordinates;
-        if (coordinates == "save"){
-            gameLogsWriter.save_game(getCurrent_desk(), isWhite_turn());
-            std::cout << "Game was saved." << std::endl;
-        }
-        first_num = convert_letter_to_num(coordinates[0]);
-        success_input = not (coordinates.length() != 2 or first_num == 0);
-    }
-    Coordinates return_coordinates(first_num -1, convert_char_to_string(coordinates[1]) - 1);
-    return return_coordinates;
-}
-
-int Game::convert_letter_to_num(char letter) {
-    if (letter == 'A') {
-        return 1;
-    }
-    if (letter == 'B') {
-        return 2;
-    }
-    if (letter == 'C') {
-        return 3;
-    }
-    if (letter == 'D') {
-        return 4;
-    }
-    if (letter == 'E') {
-        return 5;
-    }
-    if (letter == 'F') {
-        return 6;
-    }
-    if (letter == 'G') {
-        return 7;
-    }
-    if (letter == 'H') {
-        return 8;
-    }
-    return 0;
-}
-
-int Game::convert_char_to_string(char num_as_char) {
-    if (num_as_char == '1'){
-        return 1;
-    }
-    if (num_as_char == '2'){
-        return 2;
-    }
-    if (num_as_char == '3'){
-        return 3;
-    }
-    if (num_as_char == '4'){
-        return 4;
-    }
-    if (num_as_char == '5'){
-        return 5;
-    }
-    if (num_as_char == '6'){
-        return 6;
-    }
-    if (num_as_char == '7'){
-        return 7;
-    }
-    if (num_as_char == '8'){
-        return 8;
-    }
-}
-
-bool Game::random_player_side() {
-    int random_num = rand() % 100;
-    return random_num % 2 == 1;
-}
-
-void Game::print_msg_about_figure_choice(Coordinates figure_coordinates) {
-    std::cout << "You chose figure : " << this->getCurrent_desk()->
-            get_figure_by_coordinates(figure_coordinates.getX(), figure_coordinates.getY())->getName() << std::endl;
-}
-
-bool Game::player_turn(bool is_white_move, Coordinates old_coordinates, Coordinates new_coordinates) {
-    if (getCurrent_desk()->get_figure_by_coordinates(old_coordinates.getX(), old_coordinates.getY())->getSide() == is_white_move){
-        return move_figure(old_coordinates.getX(), old_coordinates.getY(), new_coordinates.getX(), new_coordinates.getY());
-    }
-    else{
-        return false;
-    }
-}
-
-
Index: Game/Game.h
===================================================================
--- Game/Game.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Game/Game.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,67 +0,0 @@
-//
-// Created by Max Yurchenko on 05.09.2018.
-//
-
-#ifndef CHESS_GAME_H
-#define CHESS_GAME_H
-
-#include "../Desk.h"
-#include "stdio.h"
-#include "ctime"
-#include "../LogsWriter/GameLogsWriter.h"
-
-class Game {
-    Desk *current_desk;
-
-    bool is_game_finished;
-
-    bool white_turn;
-
-    GameLogsWriter gameLogsWriter;
-public:
-    void setWhite_turn(bool white_turn);
-
-public:
-    bool isWhite_turn() const;
-
-    void setIs_game_finished(bool is_game_finished);
-
-    Desk *getCurrent_desk() const;
-
-    bool get_is_game_finished() const;
-
-    void initialize_game();
-
-    bool move_figure(int old_x, int old_y, int new_x, int new_y);
-
-    void finish_game();
-
-    int input_coordinate(const char *coord_name);
-
-    bool is_mate(int x, int y);
-
-    virtual bool player_turn(bool is_white_turn);
-
-    void print_msg_about_success_move(int old_x, int old_y, int new_x, int new_y);
-
-    void print_msg_about_failed_move(int old_x, int old_y, int new_x, int new_y);
-
-    void print_request_to_move_again();
-
-    void write_log_about_move(Figure *figure, int old_x, int old_y, int new_x, int new_y);
-
-    Coordinates input_coordinates();
-
-    int convert_letter_to_num(char letter);
-
-    int convert_char_to_string(char num_as_char);
-
-    bool random_player_side();
-
-    void print_msg_about_figure_choice(Coordinates figure_coordinates);
-
-    bool player_turn(bool is_white_move, Coordinates old_coordinates, Coordinates new_coordinates);
-};
-
-
-#endif //CHESS_GAME_H
Index: Game/PVE_GAME.cpp
===================================================================
--- Game/PVE_GAME.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Game/PVE_GAME.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,65 +0,0 @@
-//
-// Created by Max Yurchenko on 19.09.2018.
-//
-
-#include "PVE_GAME.h"
-
-PVE_GAME::PVE_GAME() {
-    initialize_game();
-    player_side = random_player_side();
-    engine_side = not player_side;
-    is_player_turn = player_side;
-}
-
-void PVE_GAME::engine_turn(bool is_white_turn) {
-    Engine engine(this->getCurrent_desk(), is_white_turn);
-    Move engine_move = engine.move();
-    if (this->getCurrent_desk()->move_figure(engine_move.getOld_coordinates(), engine_move.getNew_coordinates())){
-//        this->setWhite_turn(not is_white_turn);
-        this->setIs_game_finished(is_mate(engine_move.getNew_coordinates().getX(), engine_move.getNew_coordinates().getY()));
-    }
-}
-
-void PVE_GAME::pve_game() {
-    initialize_game();
-
-    this->setWhite_turn(true);
-
-    while (not this->get_is_game_finished()){
-        chessGraphic.print_desk(getCurrent_desk());
-        if (is_player_turn){
-            human_turn(isWhite_turn());
-        } else{
-            engine_turn(isWhite_turn());
-            is_player_turn = not is_player_turn;
-            setWhite_turn(not isWhite_turn());
-        }
-    }
-}
-
-void PVE_GAME::write_desk() {
-    gameLogsWriter.write_current_desk(getCurrent_desk(), false);
-}
-
-void PVE_GAME::human_turn(bool is_white_turn) {
-    std::cout << "Input figure to move" << std::endl;
-    Coordinates figure_coordinates = input_coordinates();
-    print_msg_about_figure_choice(figure_coordinates);
-
-    std::cout << "Input new coordinates" << std::endl;
-    Coordinates new_coordinates = input_coordinates();
-
-    if (player_turn(isWhite_turn(), figure_coordinates, new_coordinates)) {
-        print_msg_about_success_move(figure_coordinates.getX(), figure_coordinates.getY(),
-                                     new_coordinates.getX(), new_coordinates.getY());
-        setWhite_turn(not isWhite_turn());
-        this->setIs_game_finished(is_mate(new_coordinates.getX(), new_coordinates.getY()));
-        this->is_player_turn = not this->is_player_turn;
-    } else {
-        getCurrent_desk()->get_figure_by_coordinates(figure_coordinates)->print_possible_moves();
-        print_msg_about_failed_move(figure_coordinates.getX(), figure_coordinates.getY(),
-                                    new_coordinates.getX(), new_coordinates.getY());
-    }
-    write_desk();
-    figuresPossibleMovesWriter.write_all_figures_possible_moves(getCurrent_desk());
-}
Index: Game/PVE_GAME.h
===================================================================
--- Game/PVE_GAME.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Game/PVE_GAME.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,35 +0,0 @@
-//
-// Created by Max Yurchenko on 19.09.2018.
-//
-
-#ifndef CHESS_PVE_GAME_H
-#define CHESS_PVE_GAME_H
-
-
-#include "Game.h"
-#include "../Graphics/ChessGraphic.h"
-#include "../LogsWriter/FiguresPossibleMovesWriter.h"
-#include "../Engine/Engine.h"
-
-class PVE_GAME : public Game{
-
-    bool is_player_turn;
-    bool player_side;
-    bool engine_side;
-    GameLogsWriter gameLogsWriter;
-    ChessGraphic chessGraphic;
-    FiguresPossibleMovesWriter figuresPossibleMovesWriter;
-public:
-    PVE_GAME();
-
-    void write_desk();
-
-    void pve_game();
-
-    void human_turn(bool is_white_turn);
-
-    void engine_turn(bool side);
-};
-
-
-#endif //CHESS_PVE_GAME_H
Index: Game/PVP_GAME.cpp
===================================================================
--- Game/PVP_GAME.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Game/PVP_GAME.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,52 +0,0 @@
-//
-// Created by Max Yurchenko on 05.09.2018.
-//
-
-#include "PVP_GAME.h"
-
-void PVP_GAME::pvp_game(bool is_game_online) {
-
-    //////////////////////////////////////////
-    //  1) Initialize Game
-    //  2) bool is_game_online
-    //  3) Делаем ход, если играем белыми
-    //  4) Если черными, ждем хода противника(онлайн)
-    /////////////////////////////////////////
-    initialize_game();
-
-    this->player1_side = random_player_side();
-    this->player1_side = not this->player1_side;
-    this->setWhite_turn(true);
-
-    while (not this->get_is_game_finished()) {
-
-        chessGraphic.print_desk(getCurrent_desk());
-
-        if (is_game_online) {
-            // Онлайн игра
-        } else {
-            // Локальная игра
-            local_game();
-        }
-    }
-}
-
-void PVP_GAME::local_game() {
-    std::cout << "Input figure to move" << std::endl;
-    Coordinates figure_coordinates = input_coordinates();
-    print_msg_about_figure_choice(figure_coordinates);
-
-    std::cout << "Input new coordinates" << std::endl;
-    Coordinates new_coordinates = input_coordinates();
-
-    if (player_turn(isWhite_turn(), figure_coordinates, new_coordinates)) {
-        print_msg_about_success_move(figure_coordinates.getX(), figure_coordinates.getY(),
-                                     new_coordinates.getX(), new_coordinates.getY());
-        setWhite_turn(not isWhite_turn());
-        this->setIs_game_finished(is_mate(new_coordinates.getX(), new_coordinates.getY()));
-    } else {
-        getCurrent_desk()->get_figure_by_coordinates(figure_coordinates)->print_possible_moves();
-        print_msg_about_failed_move(figure_coordinates.getX(), figure_coordinates.getY(),
-                                    new_coordinates.getX(), new_coordinates.getY());
-    }
-}
Index: Game/PVP_GAME.h
===================================================================
--- Game/PVP_GAME.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Game/PVP_GAME.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,27 +0,0 @@
-//
-// Created by Max Yurchenko on 05.09.2018.
-//
-
-#ifndef CHESS_PVP_GAME_H
-#define CHESS_PVP_GAME_H
-
-#include "Game.h"
-#include "../Graphics/ChessGraphic.h"
-
-class PVP_GAME : public Game{
-
-    bool player1_side;
-
-    bool player2_side;
-
-    ChessGraphic chessGraphic{};
-
-public:
-
-    void local_game();
-
-    void pvp_game(bool is_game_online);
-};
-
-
-#endif //CHESS_PVP_GAME_H
Index: Graphics/ChessGraphic.cpp
===================================================================
--- Graphics/ChessGraphic.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Graphics/ChessGraphic.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,54 +0,0 @@
-//
-// Created by Max Yurchenko on 08.09.2018.
-//
-
-#include "ChessGraphic.h"
-
-void ChessGraphic::print_letters() {
-    for (auto letter : this->top_letters){
-        std::cout << "  " << letter << "  ";
-    }
-}
-
-void ChessGraphic::print_horizontal_separate_lane() {
-    std::cout << std::endl;
-    for(int i=0; i<40; i++)
-    {
-        std::cout<<"-";
-    }
-    std::cout << std::endl;
-}
-
-void ChessGraphic::print_desk(Desk *desk) {
-    clear_desk();
-    print_letters();
-    print_horizontal_separate_lane();
-    for (auto i = 0; i < 8;  i++){
-        for (auto j = 0; j < 8; j++){
-            print_figure_on_cell(desk->get_figure_by_coordinates(j, i));
-        }
-        std::cout << std::endl;
-    }
-}
-
-void ChessGraphic::print_figure_on_cell(Figure *figure) {
-    bool no_fig = true;
-    if (figure->getDesk_name().length() == 3){
-        std::cout<<figure->getDesk_name() << "  ";
-        no_fig = false;
-    } if(figure->getDesk_name().length() == 4) {
-        std::cout << figure->getDesk_name() << " ";
-        no_fig = false;
-    }
-    if (no_fig) {
-        std::cout << "     ";
-    }
-}
-
-void ChessGraphic::clear_desk() {
-    if (getenv("windir") == nullptr) {
-        system("clear");
-    } else{
-        system("cls");
-    }
-}
Index: Graphics/ChessGraphic.h
===================================================================
--- Graphics/ChessGraphic.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Graphics/ChessGraphic.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,25 +0,0 @@
-//
-// Created by Max Yurchenko on 08.09.2018.
-//
-
-#ifndef CHESS_CHESSGRAPHIC_H
-#define CHESS_CHESSGRAPHIC_H
-
-#include "../Desk.h"
-
-class ChessGraphic{
-    char top_letters[8]={'A','B','C','D','E','F','G','H'};
-public:
-    void print_letters();
-
-    void print_horizontal_separate_lane();
-
-    void print_desk(Desk *desk);
-
-    void print_figure_on_cell(Figure *figure);
-
-    void clear_desk();
-};
-
-
-#endif //CHESS_CHESSGRAPHIC_H
Index: LogsFiles/Figures/Black/bishop.txt
===================================================================
--- LogsFiles/Figures/Black/bishop.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/bishop.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,6 +0,0 @@
-5,7
-4,6
-3,5
-2,4
-1,3
-0,2
Index: LogsFiles/Figures/Black/castle.txt
===================================================================
--- LogsFiles/Figures/Black/castle.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/castle.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,1 +0,0 @@
-7,7
Index: LogsFiles/Figures/Black/king.txt
===================================================================
--- LogsFiles/Figures/Black/king.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/king.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,2 +0,0 @@
-4,7
-4,6
Index: LogsFiles/Figures/Black/Knight.txt
===================================================================
--- LogsFiles/Figures/Black/Knight.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/Knight.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,4 +0,0 @@
-6,7
-4,6
-5,5
-7,5
Index: LogsFiles/Figures/Black/NoFigure.txt
===================================================================
--- LogsFiles/Figures/Black/NoFigure.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/NoFigure.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,1 +0,0 @@
-0,0
Index: LogsFiles/Figures/Black/Pawn0.txt
===================================================================
--- LogsFiles/Figures/Black/Pawn0.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/Pawn0.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,1 +0,0 @@
-0,6
Index: LogsFiles/Figures/Black/Pawn1.txt
===================================================================
--- LogsFiles/Figures/Black/Pawn1.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/Pawn1.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,2 +0,0 @@
-1,6
-1,4
Index: LogsFiles/Figures/Black/Pawn2.txt
===================================================================
--- LogsFiles/Figures/Black/Pawn2.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/Pawn2.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,2 +0,0 @@
-2,6
-2,4
Index: LogsFiles/Figures/Black/Pawn3.txt
===================================================================
--- LogsFiles/Figures/Black/Pawn3.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/Pawn3.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,2 +0,0 @@
-3,6
-3,4
Index: LogsFiles/Figures/Black/Pawn4.txt
===================================================================
--- LogsFiles/Figures/Black/Pawn4.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/Pawn4.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,1 +0,0 @@
-4,4
Index: LogsFiles/Figures/Black/Pawn5.txt
===================================================================
--- LogsFiles/Figures/Black/Pawn5.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/Pawn5.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,2 +0,0 @@
-5,6
-5,4
Index: LogsFiles/Figures/Black/Pawn6.txt
===================================================================
--- LogsFiles/Figures/Black/Pawn6.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/Pawn6.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,2 +0,0 @@
-6,6
-6,4
Index: LogsFiles/Figures/Black/Pawn7.txt
===================================================================
--- LogsFiles/Figures/Black/Pawn7.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/Pawn7.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,2 +0,0 @@
-7,6
-7,4
Index: LogsFiles/Figures/Black/queen.txt
===================================================================
--- LogsFiles/Figures/Black/queen.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/Black/queen.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,5 +0,0 @@
-3,7
-4,6
-5,5
-6,4
-7,3
Index: LogsFiles/Figures/White/bishop.txt
===================================================================
--- LogsFiles/Figures/White/bishop.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/bishop.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,6 +0,0 @@
-5,0
-4,1
-3,2
-2,3
-1,4
-0,5
Index: LogsFiles/Figures/White/castle.txt
===================================================================
--- LogsFiles/Figures/White/castle.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/castle.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,1 +0,0 @@
-7,0
Index: LogsFiles/Figures/White/king.txt
===================================================================
--- LogsFiles/Figures/White/king.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/king.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,2 +0,0 @@
-4,0
-4,1
Index: LogsFiles/Figures/White/Knight.txt
===================================================================
--- LogsFiles/Figures/White/Knight.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/Knight.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,4 +0,0 @@
-6,0
-7,2
-5,2
-4,1
Index: LogsFiles/Figures/White/Pawn0.txt
===================================================================
--- LogsFiles/Figures/White/Pawn0.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/Pawn0.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,3 +0,0 @@
-0,1
-0,2
-0,3
Index: LogsFiles/Figures/White/Pawn1.txt
===================================================================
--- LogsFiles/Figures/White/Pawn1.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/Pawn1.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,3 +0,0 @@
-1,1
-1,2
-1,3
Index: LogsFiles/Figures/White/Pawn2.txt
===================================================================
--- LogsFiles/Figures/White/Pawn2.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/Pawn2.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,3 +0,0 @@
-2,1
-2,2
-2,3
Index: LogsFiles/Figures/White/Pawn3.txt
===================================================================
--- LogsFiles/Figures/White/Pawn3.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/Pawn3.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,3 +0,0 @@
-3,1
-3,2
-3,3
Index: LogsFiles/Figures/White/Pawn4.txt
===================================================================
--- LogsFiles/Figures/White/Pawn4.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/Pawn4.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,1 +0,0 @@
-4,3
Index: LogsFiles/Figures/White/Pawn5.txt
===================================================================
--- LogsFiles/Figures/White/Pawn5.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/Pawn5.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,3 +0,0 @@
-5,1
-5,2
-5,3
Index: LogsFiles/Figures/White/Pawn6.txt
===================================================================
--- LogsFiles/Figures/White/Pawn6.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/Pawn6.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,3 +0,0 @@
-6,1
-6,2
-6,3
Index: LogsFiles/Figures/White/Pawn7.txt
===================================================================
--- LogsFiles/Figures/White/Pawn7.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/Pawn7.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,3 +0,0 @@
-7,1
-7,2
-7,3
Index: LogsFiles/Figures/White/queen.txt
===================================================================
--- LogsFiles/Figures/White/queen.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Figures/White/queen.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,1 +0,0 @@
-3,0
Index: LogsFiles/Desk.txt
===================================================================
--- LogsFiles/Desk.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsFiles/Desk.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,64 +0,0 @@
-00 castle White
-10 Knight White
-20 bishop White
-30 queen White
-40 king White
-50 bishop White
-60 Knight White
-70 castle White
-01 Pawn0 White
-11 Pawn1 White
-21 Pawn2 White
-31 Pawn3 White
-41 NoFigure Black
-51 Pawn5 White
-61 Pawn6 White
-71 Pawn7 White
-02 NoFigure Black
-12 NoFigure Black
-22 NoFigure Black
-32 NoFigure Black
-42 NoFigure Black
-52 NoFigure Black
-62 NoFigure Black
-72 NoFigure Black
-03 NoFigure Black
-13 NoFigure Black
-23 NoFigure Black
-33 NoFigure Black
-43 Pawn4 White
-53 NoFigure Black
-63 NoFigure Black
-73 NoFigure Black
-04 NoFigure Black
-14 NoFigure Black
-24 NoFigure Black
-34 NoFigure Black
-44 Pawn4 Black
-54 NoFigure Black
-64 NoFigure Black
-74 NoFigure Black
-05 NoFigure Black
-15 NoFigure Black
-25 NoFigure Black
-35 NoFigure Black
-45 NoFigure Black
-55 NoFigure Black
-65 NoFigure Black
-75 NoFigure Black
-06 Pawn0 Black
-16 Pawn1 Black
-26 Pawn2 Black
-36 Pawn3 Black
-46 NoFigure Black
-56 Pawn5 Black
-66 Pawn6 Black
-76 Pawn7 Black
-07 castle Black
-17 Knight Black
-27 bishop Black
-37 queen Black
-47 king Black
-57 bishop Black
-67 Knight Black
-77 castle Black
Index: LogsWriter/FiguresPossibleMovesWriter.cpp
===================================================================
--- LogsWriter/FiguresPossibleMovesWriter.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsWriter/FiguresPossibleMovesWriter.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,47 +0,0 @@
-//
-// Created by Max Yurchenko on 06.09.2018.
-//
-
-#include "FiguresPossibleMovesWriter.h"
-
-void FiguresPossibleMovesWriter::write_all_figures_possible_moves(Desk *desk) {
-    for (int i = 0; i < 8; i++){
-        for (int j = 0; j < 8; j++) {
-            auto figure = desk->get_figure_by_coordinates(i, j);
-            if (figure->getName() != "No figure")
-                write_figure_possible_moves(figure, figure->getSide());
-        }
-    }
-}
-
-FiguresPossibleMovesWriter::FiguresPossibleMovesWriter() {
-    this->path_to_white_figure_logs_directory = "../LogsFiles/Figures/White/";
-    this->path_to_black_figure_logs_directory = "../LogsFiles/Figures/Black/";
-}
-
-
-bool FiguresPossibleMovesWriter::DoesFileExist(const std::string &name) {
-    std::ifstream f(name.c_str());
-    return f.good();
-}
-
-void FiguresPossibleMovesWriter::write_figure_possible_moves(Figure *figure, bool side) {
-    if (figure->getName() == "No figure")
-        return;
-    if (side){
-        this->full_path_to_output_file = this->path_to_white_figure_logs_directory +  figure->getName() + ".txt";
-    } else{
-        this->full_path_to_output_file = this->path_to_black_figure_logs_directory +  figure->getName() + ".txt";
-    }
-
-    std::ofstream output_file;
-    output_file.open(this->full_path_to_output_file);
-
-
-    // Записываем текущее положение
-    output_file << std::to_string(figure->getCoordinates().getX()) << "," << std::to_string(figure->getCoordinates().getY()) << std::endl;
-
-    for (auto move : figure->getPossible_moves()){
-        output_file << std::to_string(move.getNew_coordinates().getX()) << "," << std::to_string(move.getNew_coordinates().getY()) << std::endl;
-    }
-}
Index: LogsWriter/FiguresPossibleMovesWriter.h
===================================================================
--- LogsWriter/FiguresPossibleMovesWriter.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsWriter/FiguresPossibleMovesWriter.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,28 +0,0 @@
-//
-// Created by Max Yurchenko on 06.09.2018.
-//
-
-#ifndef CHESS_FIGURESPOSSIBLEMOVESWRITER_H
-#define CHESS_FIGURESPOSSIBLEMOVESWRITER_H
-
-#include "../Desk.h"
-#include "fstream"
-
-
-class FiguresPossibleMovesWriter {
-    std::string path_to_white_figure_logs_directory;
-    std::string path_to_black_figure_logs_directory;
-    std::string full_path_to_output_file;
-public:
-    FiguresPossibleMovesWriter();
-
-    void write_all_figures_possible_moves(Desk *desk);
-
-    void write_figure_possible_moves(Figure *figure, bool side);
-
-
-    bool DoesFileExist (const std::string& name);
-};
-
-
-#endif //CHESS_FIGURESPOSSIBLEMOVESWRITER_H
Index: LogsWriter/GameLogsWriter.cpp
===================================================================
--- LogsWriter/GameLogsWriter.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsWriter/GameLogsWriter.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,64 +0,0 @@
-//
-// Created by Max Yurchenko on 08.09.2018.
-//
-
-#include "GameLogsWriter.h"
-
-GameLogsWriter::GameLogsWriter() {
-    this->log_filename = "GameLogs";
-    this->log_file_path = "../LogsFiles/" + this->log_filename+ ".txt";
-    this->log_file.open(this->log_file_path);
-    this->desk_log_filename = "Desk";
-    this->desk_log_file_path = "../LogsFiles/" + this->desk_log_filename+ ".txt";
-    this->desk_log_file.open(this->desk_log_file_path);
-    this->game_save_filename = "../LogsFiles/SavedGames/";
-    this->game_save_file_path = removeSpaces(this->game_save_filename + generate_game_save_filename() + ".txt");
-    this->game_save_file.open(this->game_save_file_path);
-}
-
-void GameLogsWriter::write_log_about_move(Figure *figure, int old_x, int old_y, int new_x, int new_y) {
-    log_file << figure->get_side_as_string() << " " << figure->getName() << " was moved from : (" << old_x << " , " << old_y << ") to (" << new_x << " , " << new_y << ")"<< std::endl;
-}
-
-void GameLogsWriter::write_current_desk(Desk *desk, bool to_save_game) {
-    std::ofstream desk_log_file;
-    if (to_save_game){
-        desk_log_file.open(this->game_save_file_path);
-    } else{
-        std::ofstream log_file;
-        desk_log_file.open(this->desk_log_file_path);
-    }
-    for (int i = 0; i < 8; i++){
-        for(int j = 0; j < 8; j++){
-            desk_log_file << std::to_string(j) << std::to_string(i) << " " << desk->get_figure_by_coordinates(j, i)->getName() << " " << desk->get_figure_by_coordinates(j, i)->get_side_as_string()<< std::endl;
-        }
-    }
-}
-
-void GameLogsWriter::save_game(Desk *desk, bool is_white_turn) {
-    this->game_save_file << std::to_string(is_white_turn) << std::endl;
-    write_current_desk(desk, true);
-}
-
-std::string GameLogsWriter::generate_game_save_filename() {
-    time_t result = time(nullptr);
-    std::string time_string = asctime(localtime(&result));
-    // Удаляем преенос строки в конце
-    return time_string.substr(0, time_string.length() - 1);
-}
-
-std::string GameLogsWriter::removeSpaces(std::string str) {
-    std::string new_string;
-    for(auto symbol : str){
-        if (symbol != ' ' and symbol != ':'){
-            new_string.push_back(symbol);
-        }else{
-            new_string.push_back('_');
-        }
-    }
-    return new_string;
-}
-
-
-
-
Index: LogsWriter/GameLogsWriter.h
===================================================================
--- LogsWriter/GameLogsWriter.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ LogsWriter/GameLogsWriter.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,39 +0,0 @@
-//
-// Created by Max Yurchenko on 08.09.2018.
-//
-
-#ifndef CHESS_GAMELOGSWRITER_H
-#define CHESS_GAMELOGSWRITER_H
-
-
-#include <string>
-#include <fstream>
-#include <ctime>
-#include "../Desk.h"
-
-class GameLogsWriter {
-    std::string log_file_path;
-    std::string log_filename;
-    std::ofstream log_file;
-    std::ofstream desk_log_file;
-    std::string desk_log_filename;
-    std::string desk_log_file_path;
-    std::string game_save_filename;
-    std::string game_save_file_path;
-    std::ofstream game_save_file;
-public:
-    GameLogsWriter();
-
-    void write_log_about_move(Figure *figure, int old_x, int old_y, int new_x, int new_y);
-
-    void write_current_desk(Desk *desk, bool to_save_game);
-
-    void save_game(Desk *desk, bool is_white_turn);
-
-    std::string generate_game_save_filename();
-
-    std::string removeSpaces(std::string str);
-};
-
-
-#endif //CHESS_GAMELOGSWRITER_H
Index: .gitignore
===================================================================
--- .gitignore	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ .gitignore	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,36 +0,0 @@
-# Compiled Object files
-*.slo
-*.lo
-*.o
-*.obj
-
-# Precompiled Headers
-*.gch
-*.pch
-
-# Compiled Dynamic libraries
-*.so
-*.dylib
-*.dll
-
-# Fortran module files
-*.mod
-
-# Compiled Static libraries
-*.lai
-*.la
-*.a
-*.lib
-
-# Executables
-*.exe
-*.out
-*.app
-
-\.idea/
-
-
-
-cmake-build-debug/
-
-cmake-build-release/
Index: builder.py
===================================================================
--- builder.py	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ builder.py	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,25 +0,0 @@
-import os
-
-def add_file(command, filename):
-    return command + " " + str(filename)
-
-os_command = "g++ main.cpp"
-
-os_command = add_file(os_command, "Game/*.cpp")
-
-os_command = add_file(os_command, "Figures/*.cpp")
-
-os_command = add_file(os_command, "LogsWriter/*.cpp")
-
-os_command = add_file(os_command, "Desk.cpp")
-
-os_command = add_file(os_command, "Move.cpp")
-
-os_command = add_file(os_command, "Coordinates.cpp")
-
-os_command = add_file(os_command, "Graphics/*.cpp")
-
-os_command = add_file(os_command, "Engine/*.cpp")
-
-
-os.system(os_command)
Index: cache_cleaner.py
===================================================================
--- cache_cleaner.py	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ cache_cleaner.py	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,12 +0,0 @@
-import os
-
-
-# print("This script will delete all saved games\n")
-# agree = str()
-# while(not(agree.lower() == "y" or agree.lower == "n")):
-#     agree = input("Are u sure?:\n")
-
-
-# if (agree.lower == "y"):
-os.system('find . -name "*.txt" -type f -delete')
-print("Cached was cleaned")
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ CMakeLists.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,15 +0,0 @@
-cmake_minimum_required(VERSION 3.12)
-project(Chess)
-
-set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -static-libstdc++ -static-libgcc")
-set(CMAKE_CXX_STANDARD 17)
-
-# Detect and add SFML
-
-
-
-add_executable(Chess main.cpp Figures/Bishop.cpp Figures/Bishop.h Figures/Castle.cpp Figures/Castle.h Figures/Figure.cpp
-        Figures/Figure.h Figures/King.cpp Figures/King.h Figures/Knight.cpp Figures/Knight.h Figures/Pawn.cpp Figures/Pawn.h
-        Figures/Queen.cpp Figures/Queen.h Coordinates.cpp Coordinates.h Desk.cpp Desk.h Move.cpp Move.h Game/Game.cpp
-        Game/Game.h Game/PVP_GAME.cpp Game/PVP_GAME.h LogsWriter/FiguresPossibleMovesWriter.cpp LogsWriter/FiguresPossibleMovesWriter.h
-        LogsWriter/GameLogsWriter.cpp LogsWriter/GameLogsWriter.h Graphics/ChessGraphic.cpp Graphics/ChessGraphic.h Game/PVE_GAME.cpp Game/PVE_GAME.h Engine/MoveWeight.cpp Engine/MoveWeight.h Engine/Engine.cpp Engine/Engine.h)
\ No newline at end of file
Index: Coordinates.cpp
===================================================================
--- Coordinates.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Coordinates.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,46 +0,0 @@
-//
-// Created by Max Yurchenko on 24.08.2018.
-//
-
-#include "Coordinates.h"
-
-void Coordinates::setX(int x) {
-    Coordinates::x = x;
-}
-
-void Coordinates::setY(int y) {
-    Coordinates::y = y;
-}
-
-int Coordinates::getX() const {
-    return x;
-}
-
-int Coordinates::getY() const {
-    return y;
-}
-
-Coordinates::Coordinates(int x, int y) {
-    this->x = x;
-    this->y = y;
-}
-
-Coordinates::Coordinates() {
-
-}
-
-bool Coordinates::operator==(const Coordinates &coord_1) {
-    return coord_1.x == this->x and coord_1.y == this->y;
-}
-
-bool Coordinates::operator!=(const Coordinates &coord_1) {
-    return coord_1.getX() != getX() or coord_1.getY() !=getY();
-}
-
-void Coordinates::print_coordinates() {
-    //////////////////////////////////////////
-    //  Дебаг функия
-    /////////////////////////////////////////
-    std::cout<< "X coordinate : " << getX() << std::endl << "Y coordinate : " << getY() << std::endl;
-    std::cout << "--------------------------------------------" << std::endl;
-}
Index: Coordinates.h
===================================================================
--- Coordinates.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Coordinates.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,34 +0,0 @@
-//
-// Created by Max Yurchenko on 24.08.2018.
-//
-
-#ifndef CHESS_COORDINATES_H
-#define CHESS_COORDINATES_H
-
-
-#include <iostream>
-
-class Coordinates {
-    int x,y;
-public:
-    int getX() const;
-
-    int getY() const;
-
-    Coordinates(int x, int y);
-
-    Coordinates();
-
-    void setX(int x);
-
-    void setY(int y);
-
-    bool operator== (const Coordinates& coord_1);
-
-    bool operator!=(const Coordinates&coord_1);
-
-    void print_coordinates();
-};
-
-
-#endif //CHESS_COORDINATES_H
Index: Desk.cpp
===================================================================
--- Desk.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Desk.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,256 +0,0 @@
-//
-// Created by Max Yurchenko on 03.09.2018.
-//
-
-#include "Desk.h"
-
-Desk::Desk() {
-    for (int i=0; i<8;i++)
-        for(int j=0;j<8; j++) {
-            {
-                desk[i][j] = new Figure;
-            }
-        }
-}
-
-Figure *Desk::get_figure_by_coordinates(int x, int y) {
-    return desk[x][y];
-}
-
-void Desk::initialize_desk() {
-    initialize_castles(true);
-    initialize_castles(false);
-
-    initialize_knights(true);
-    initialize_knights(false);
-
-    initialize_bishops(true);
-    initialize_bishops(false);
-
-    initialize_king(true);
-    initialize_king(false);
-
-    initialize_queen(true);
-    initialize_queen(false);
-
-    // White Pawns
-    for (uint8_t i = 0; i < 8; i++){
-        initialize_pawn(true, i);
-    }
-
-    // Black Pawns
-    for (uint8_t i = 0; i < 8; i++){
-        initialize_pawn(false, i);
-    }
-
-    reinitialize_white_black_figures();
-
-    initialize_possible_moves();
-
-    reinitialize_white_black_figures();
-}
-
-void Desk::print_desk() {
-    //////////////////////////////////////////
-    //  Дебаг функция
-    //////////////////////////////////////////
-    for (int i = 0; i < 8; i ++){
-        for (int j = 0; j < 8; j ++) {
-            if (not (desk[j][i]->getName() == "No figure")) {
-                Figure *figure = desk[j][i];
-                std::cout << "Figure on coordinates: " << j << " : "<< i  << std::endl;
-                std::cout << desk[j][i]->getName() << std::endl;
-                std::cout << "-------------------------" << std::endl;
-            }
-        }
-    }
-}
-
-bool Desk::move_figure(Coordinates old_coordinates, Coordinates new_coordinates) {
-    Figure *figure = desk[old_coordinates.getX()][old_coordinates.getY()];
-    Figure *old_figure = new Figure;
-    if (is_move_possible(*figure, new_coordinates)){
-        this->desk[new_coordinates.getX()][new_coordinates.getY()] = figure;
-        this->desk[new_coordinates.getX()][new_coordinates.getY()]->setCoordinates(new_coordinates);
-        this->desk[old_coordinates.getX()][old_coordinates.getY()] = old_figure;
-        reinitialize_white_black_figures();
-        initialize_possible_moves();
-        return true;
-    } else {
-        return false;
-    }
-}
-
-bool Desk::is_move_possible(Figure figure, Coordinates new_coordinates) {
-    for(auto move : figure.getPossible_moves()){
-        Coordinates possible_coordinates = move.getNew_coordinates();
-        if (possible_coordinates == new_coordinates){
-            return true;
-        }
-    }
-    return false;
-}
-
-void Desk::reinitialize_white_black_figures() {
-    white_figures.clear();
-    black_figures.clear();
-    for (int i = 0; i < 8; i++){
-        for(int j = 0; j < 8; j ++){
-            if(desk[i][j]->getSide() and not (desk[i][j]->getName() == "no figure")){
-                white_figures.push_back(*desk[i][j]);
-            }
-            if(not desk[i][j]->getSide() and  desk[i][j]->getName() != "no figure"){
-                black_figures.push_back(*desk[i][j]);
-            }
-        }
-    }
-}
-
-void Desk::initialize_possible_moves() {
-    for (int i = 0; i < 8; i++){
-        for(int j = 0; j < 8; j ++){
-            this->desk[i][j]->clear_possible_moves();
-            this->desk[i][j]->calculate_possible_moves(white_figures, black_figures);
-        }
-    }
-}
-
-const std::vector<Figure> &Desk::getWhite_figures() const {
-    return white_figures;
-}
-
-const std::vector<Figure> &Desk::getBlack_figures() const {
-    return black_figures;
-}
-
-Figure *Desk::get_figure_by_coordinates(Coordinates coordinates) {
-    return desk[coordinates.getX()][coordinates.getY()];
-}
-
-void Desk::print_black_figures(bool to_file) {
-    ////////////////////////////////////////////
-    //  Дебаг функция
-    /////////////////////////////////////////
-    std::ofstream file;
-    file.open("black_figures.txt");
-
-    for (auto figure : black_figures){
-        file << figure.getName() << " : " << figure.getCoordinates().getX() << " , " << figure.getCoordinates().getY() << std::endl;
-    }
-}
-
-void Desk::print_white_figures(bool to_file) {
-    ////////////////////////////////////////////
-    //  Дебаг функция
-    /////////////////////////////////////////
-    std::ofstream file;
-    file.open("white_figures.txt");
-
-    for (auto figure : white_figures){
-        file << figure.getName() << " : " << figure.getCoordinates().getX() << " , " << figure.getCoordinates().getY() << std::endl;
-    }
-}
-
-void Desk::initialize_castles(bool side) {
-    Coordinates castle1_coordinates;
-    Coordinates castle2_coordinates;
-    castle1_coordinates.setX(0);
-    castle2_coordinates.setX(7);
-    if (side){
-        castle1_coordinates.setY(0);
-        castle2_coordinates.setY(0);
-
-    }else{
-        castle1_coordinates.setY(7);
-        castle2_coordinates.setY(7);
-    }
-    Castle *castle1 = new Castle(side, castle1_coordinates);
-    Castle *castle2 = new Castle(side, castle2_coordinates);
-
-    desk[castle1_coordinates.getX()][castle1_coordinates.getY()] = castle1;
-    desk[castle2_coordinates.getX()][castle2_coordinates.getY()] = castle2;
-}
-
-void Desk::initialize_king(bool side) {
-    Coordinates king_coordinates{};
-    king_coordinates.setX(4);
-
-    if (side){
-        king_coordinates.setY(0);
-    } else{
-        king_coordinates.setY(7);
-    }
-
-    King *king = new King(side, king_coordinates);
-
-    desk[king_coordinates.getX()][king_coordinates.getY()] = king;
-}
-
-void Desk::initialize_queen(bool side) {
-    Coordinates queen_coordinates{};
-    queen_coordinates.setX(3);
-
-    if (side){
-        queen_coordinates.setY(0);
-    } else{
-        queen_coordinates.setY(7);
-    }
-
-    Queen *queen = new Queen(side, queen_coordinates);
-
-    desk[queen_coordinates.getX()][queen_coordinates.getY()] = queen;
-}
-
-void Desk::initialize_bishops(bool side) {
-    Coordinates bishop1_coordinates;
-    Coordinates bishop2_coordinates;
-    bishop1_coordinates.setX(2);
-    bishop2_coordinates.setX(5);
-
-    if (side){
-        bishop1_coordinates.setY(0);
-        bishop2_coordinates.setY(0);
-    } else{
-        bishop1_coordinates.setY(7);
-        bishop2_coordinates.setY(7);
-    }
-
-    Bishop *bishop1 = new Bishop(side, bishop1_coordinates);
-    Bishop *bishop2 = new Bishop(side, bishop2_coordinates);
-
-    desk[bishop1_coordinates.getX()][bishop1_coordinates.getY()] = bishop1;
-    desk[bishop2_coordinates.getX()][bishop2_coordinates.getY()] = bishop2;
-}
-
-void Desk::initialize_knights(bool side) {
-    Coordinates knight1_coordinates;
-    Coordinates knight2_coordinates;
-    knight1_coordinates.setX(1);
-    knight2_coordinates.setX(6);
-
-    if (side){
-        knight1_coordinates.setY(0);
-        knight2_coordinates.setY(0);
-    } else{
-        knight1_coordinates.setY(7);
-        knight2_coordinates.setY(7);
-    }
-
-    Knight *knight1 = new Knight(side, knight1_coordinates);
-    Knight *knight2 = new Knight(side, knight2_coordinates);
-
-    desk[knight1_coordinates.getX()][knight1_coordinates.getY()] = knight1;
-    desk[knight2_coordinates.getX()][knight2_coordinates.getY()] = knight2;
-}
-
-void Desk::initialize_pawn(bool side, int num) {
-    Coordinates pawn_coordinates{};
-    pawn_coordinates.setX(num);
-    if (side)
-        pawn_coordinates.setY(1);
-    else
-        pawn_coordinates.setY(6);
-    Pawn *pawn = new Pawn(side, pawn_coordinates, num);
-    desk[pawn_coordinates.getX()][pawn_coordinates.getY()] = pawn;
-}
-
Index: Desk.h
===================================================================
--- Desk.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Desk.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,67 +0,0 @@
-//
-// Created by Max Yurchenko on 03.09.2018.
-//
-
-#ifndef CHESS_DESK_H
-#define CHESS_DESK_H
-
-
-#include "Figures/Figure.h"
-#include "Figures/King.h"
-#include "Figures/Pawn.h"
-#include "Figures/Knight.h"
-#include "Figures/Castle.h"
-#include "Figures/Bishop.h"
-#include "Figures/Queen.h"
-#include <fstream>
-
-class Desk {
-    Figure *desk[8][8];
-
-    std::vector<Figure> white_figures;
-    std::vector<Figure> black_figures;
-public:
-    const std::vector<Figure> &getWhite_figures() const;
-
-    const std::vector<Figure> &getBlack_figures() const;
-
-
-public:
-
-    Desk();
-
-    Figure *get_figure_by_coordinates(int x, int y);
-
-    void initialize_desk();
-
-    void print_desk();
-
-    bool move_figure(Coordinates old_coordinates, Coordinates new_coordinates);
-
-    bool is_move_possible(Figure figure, Coordinates new_coordinates);
-
-    void initialize_possible_moves();
-
-    void reinitialize_white_black_figures();
-
-    Figure *get_figure_by_coordinates(Coordinates coordinates);
-
-    void print_white_figures(bool to_file);
-
-    void print_black_figures(bool to_file);
-
-    void initialize_castles(bool side);
-
-    void initialize_knights(bool side);
-
-    void initialize_bishops(bool side);
-
-    void initialize_king(bool side);
-
-    void initialize_queen(bool side);
-
-    void initialize_pawn(bool side, int num);
-};
-
-
-#endif //CHESS_DESK_H
Index: Engine.py
===================================================================
--- Engine.py	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Engine.py	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,23 +0,0 @@
-import os
-
-def get_info_about_desk(desk_filename = "LogsFiles/Desk.txt" ):
-    data = open(desk_filename).read().split()
-    num = 0
-    figures_coordinate = []
-    figures_names = []
-    figures_side = []
-    for  info in data:
-        if (num == 0):
-            figures_coordinate.append(info)
-        if (num == 1):
-            figures_names.append(info)
-        if (num == 2):
-            figures_side.append(info)
-        num += 1
-        if (num == 3):
-            num = 0
-    figures = [ ]
-    for figure in zip(figures_coordinate, figures_names, figures_side):
-        if figure[1] == "NoFigure"
-
-get_info_about_desk()
\ No newline at end of file
Index: main.cpp
===================================================================
--- main.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ main.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,15 +0,0 @@
-#include "Game/PVP_GAME.h"
-#include "Game/PVE_GAME.h"
-
-
-int main(){
-
-    Desk *desk = new Desk();
-    desk->initialize_desk();
-//    PVE_GAME pve_game;
-//
-//    pve_game.pve_game();
-    bool is_move_white = false;
-    Engine engine(desk, is_move_white);
-    engine.print_possibilities();
-}
Index: Move.cpp
===================================================================
--- Move.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Move.cpp	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,28 +0,0 @@
-//
-// Created by Max Yurchenko on 25.08.2018.
-//
-
-#include "Move.h"
-
-void Move::setOld_coordinates(const Coordinates &old_coordinates) {
-    Move::old_coordinates = old_coordinates;
-}
-
-void Move::setNew_coordinates(const Coordinates &new_coordinates) {
-    Move::new_coordinates = new_coordinates;
-}
-
-const Coordinates &Move::getOld_coordinates() const {
-    return old_coordinates;
-}
-
-const Coordinates &Move::getNew_coordinates() const {
-    return new_coordinates;
-}
-
-Move::Move(const Coordinates &old_coordinates, const Coordinates &new_coordinates) : old_coordinates(old_coordinates),
-                                                                                     new_coordinates(new_coordinates) {}
-
-Move::Move() {
-
-}
Index: Move.h
===================================================================
--- Move.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ Move.h	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
@@ -1,28 +0,0 @@
-//
-// Created by Max Yurchenko on 25.08.2018.
-//
-
-#ifndef CHESS_MOVE_H
-#define CHESS_MOVE_H
-
-#include "Coordinates.h"
-
-class Move {
-    Coordinates old_coordinates;
-    Coordinates new_coordinates;
-public:
-    Move(const Coordinates &old_coordinates, const Coordinates &new_coordinates);
-
-    Move();
-
-    void setOld_coordinates(const Coordinates &old_coordinates);
-
-    void setNew_coordinates(const Coordinates &new_coordinates);
-
-    const Coordinates &getOld_coordinates() const;
-
-    const Coordinates &getNew_coordinates() const;
-};
-
-
-#endif //CHESS_MOVE_H
Index: requirements.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- requirements.txt	(date 1547112767000)
+++ requirements.txt	(date 1547112767000)
@@ -0,0 +1,4 @@
+pytest
+twine
+pypandoc
+pandoc
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- README.md	(date 1547148748000)
+++ README.md	(date 1547148748000)
@@ -0,0 +1,108 @@
+# chess_py
+
+![Board](http://i.stack.imgur.com/yQaOq.png)
+
+## License
+chess_py is available under the MIT license. See the [LICENSE](https://github.com/LordDarkula/chess_py/blob/master/LICENSE) file for more info.
+Copyright © 2016 Aubhro Sengupta. All rights reserved.
+
+## Talk @mv_yurchenkp (Telehram)
+
+
+## Introduction
+
+Chess_py is an open source chess library written in Python designed to aid in the creation of chess engines. Handles the chess so you can focus on the engine.
+
+## Installation
+
+To use as a immediately start up a game between two human players in the console, navigate inside the root directory of the package and run main.py. 
+
+```bash
+python main.py
+```
+
+To install package  
+
+### ``pip`` (*Recommended*)
+```bash
+pip install chess_py
+```
+
+### Or manually
+```bash
+python setup.py install
+```
+## Documentation
+
+View complete technical documentation [here](http://lorddarkula.github.io/chess_py/html/html/index.html).
+
+## Great! How do you use it? (*An Example*)
+
+Chess_py has the capability of creating games between players, either human, or AI 
+
+```python
+import chess_py
+from chess_py import Game, Human, color
+
+""" Creates a Game with 2 humans. 
+When run, this will open the console,"""
+new_game = Game(Human(color.white), Human(color.black))
+
+""" After game is completed, outcome will be stored in result.
+The integer result will be one of three values. 
+white wins - 0, black wins - 1, draw - 0.5 """
+result = new_game.play()
+```
+
+To build a chess engine on with chess_py, inherit Player and implement generate_move() 
+
+```python
+import chess_py
+from chess_py import Game, Human, color
+
+# Engine which plays the move with the highest immediate material advantage
+class MyEngine(chess_py.Player):
+    def __init__(self, input_color):
+    
+      # Creates piece value scheme to specify value of each piece.
+      self.piece_values = chess_py.PieceValues.init_manual(PAWN_VALUE=1,
+                                                            KNIGHT_VALUE=3,
+                                                            BISHOP_VALUE=3,
+                                                            ROOK_VALUE=5,
+                                                            QUEEN_VALUE=9)
+      
+      # Super call to
+      super(chess_py.Player, self).__init__(input_color)
+    
+    def generate_move(self, position):
+      # position parameter is an object of type Board
+        
+      # Finds all possible moves I can play.
+      moves = position.all_possible_moves(self.color)
+      
+      # Initalizes best move and advantage after it has been played to dummy values.
+      best_move = None
+      best_move_advantage = -99
+      
+      # Loops through possible moves
+      for move in moves:
+        """ advantage_as_result(move, piece_values) finds numerical advantage
+        as specified by piece value scheme above. Returns negative values for
+        positions of disadvantage. Returns +/-99 for checkmate. """
+        advantage = position.advantage_as_result(move, self.piece_values)
+        
+        # If this move is better than best move, it is the best move.
+        if advantage >= best_move_advantage:
+            best_move = move
+            best_move_advantage = advantage
+      
+      return best_move
+
+# If file is run as script, a Game is set up between My_engine and Human and result is printed.
+if __name__ == "__main__":
+    new_game = Game(MyEngine(color.white), Human(color.black))
+    
+    # white wins - 0, black wins - 1, draw - 0.5 
+    print("Result: ", new_game.play())
+```
+
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- main.py	(date 1547112767000)
+++ main.py	(date 1547112767000)
@@ -0,0 +1,37 @@
+# -*- coding: utf-8 -*-
+
+"""
+Chess playing program
+Everything starts here
+
+
+8 ║♜♞♝♛♚♝♞♜
+7 ║♟♟♟♟♟♟♟♟
+6 ║…………………………………
+5 ║…………………………………
+4 ║…………………………………
+3 ║…………………………………
+2 ║♙♙♙♙♙♙♙♙
+1 ║♖♘♗♕♔♗♘♖
+--╚═══════════════
+——-a b c d e f g h
+
+Copyright © 2016 Aubhro Sengupta. All rights reserved.
+"""
+
+from chess_py import color, Human, Game
+
+
+def main():
+    """
+    Main method
+    """
+    print("Creating a new game...")
+
+    new_game = Game(Human(color.white), Human(color.black))
+    result = new_game.play()
+
+    print("Result is ", result)
+
+if __name__ == "__main__":
+    main()
Index: setup.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- setup.py	(date 1547148646000)
+++ setup.py	(date 1547148646000)
@@ -0,0 +1,32 @@
+#!/usr/bin/env python
+
+import setuptools
+from setuptools import setup
+try:
+    import pypandoc
+    # pypandoc.download_pandoc()
+    read_md = lambda f: pypandoc.convert(f, 'rst')
+except ImportError:
+    print("warning: pypandoc module not found, could not convert Markdown to RST")
+    read_md = lambda f: open(f, 'r').read()
+
+
+setup(
+    name='chess_py',
+    version='3.3.0',
+    description='Python chess client',
+    long_description=read_md("README.md"),
+    platforms='MacOS X, Windows, Linux',
+    classifiers=[
+        'Development Status :: 5 - Production/Stable',
+        'Intended Audience :: Developers',
+        'License :: OSI Approved :: MIT License',
+        'Programming Language :: Python :: 3.6',
+        'Programming Language :: Python :: 2.7',
+    ],
+    author='Aubhro Sengupta',
+    author_email='maxonus2@gmail.com',
+    url='https://github.com/mv-yurchenko/chess_py',
+    license='MIT',
+    packages=setuptools.find_packages()
+)
Index: setup.cfg
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- setup.cfg	(date 1547112767000)
+++ setup.cfg	(date 1547112767000)
@@ -0,0 +1,2 @@
+[bdist_wheel]
+universal=1
Index: LICENSE
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- LICENSE	(date 1547148383000)
+++ LICENSE	(date 1547148383000)
@@ -0,0 +1,22 @@
+(The MIT License)
+
+Copyright © 2018 Maxim Yurchenko. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+'Software'), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
Index: LogsFiles/GameLogs.txt
===================================================================
--- LogsFiles/GameLogs.txt	(revision 49e96aadd9e80cf065691b4dd507e98b6b253539)
+++ tests/__init__.py	(date 1547112767000)
@@ -1,0 +1,0 @@
Index: tests/test_core/test_board.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_core/test_board.py	(date 1547112767000)
+++ tests/test_core/test_board.py	(date 1547112767000)
@@ -0,0 +1,243 @@
+from unittest import TestCase
+
+from chess_py import Board, color, Location
+from chess_py import Pawn, Knight, Bishop, Rook, Queen, King, piece_const, converter
+
+
+class TestBoard(TestCase):
+    def setUp(self):
+        self.board = Board.init_default()
+
+    def test_init_default(self):
+        white = color.white
+        black = color.black
+        test = Board([
+
+         # First rank
+         [Rook(white, Location(0, 0)), Knight(white, Location(0, 1)), Bishop(white, Location(0, 2)),
+          Queen(white, Location(0, 3)), King(white, Location(0, 4)), Bishop(white, Location(0, 5)),
+          Knight(white, Location(0, 6)), Rook(white, Location(0, 7))],
+
+         # Second rank
+         [Pawn(white, Location(1, file)) for file in range(8)],
+
+
+         # Third rank
+         [None for _ in range(8)],
+
+         # Fourth rank
+         [None for _ in range(8)],
+
+         # Fifth rank
+         [None for _ in range(8)],
+
+         # Sixth rank
+         [None for _ in range(8)],
+
+         # Seventh rank
+         [Pawn(black, Location(6, file)) for file in range(8)],
+
+         # Eighth rank
+         [Rook(black, Location(7, 0)), Knight(black, Location(7, 1)), Bishop(black, Location(7, 2)),
+             Queen(black, Location(7, 3)), King(black, Location(7, 4)), Bishop(black, Location(7, 5)),
+             Knight(black, Location(7, 6)), Rook(black, Location(7, 7))]])
+
+        self.assertEqual(self.board, test)
+
+    def test_copy(self):
+        tester = Board.init_default()
+
+        for num, row in enumerate(self.board.position):
+            for index, piece in enumerate(row):
+                self.assertEqual(piece, tester.position[num][index])
+
+    def test_piece_at_square(self):
+        self.assertEqual(self.board.piece_at_square(Location(0, 0)),
+                         Rook(color.white, Location(0, 0)))
+
+        self.assertEqual(self.board.piece_at_square(Location(1, 0)),
+                         Pawn(color.white, Location(1, 0)))
+
+        self.assertEqual(self.board.piece_at_square(Location(0, 1)),
+                         Knight(color.white, Location(0, 1)))
+
+    def test_is_square_empty(self):
+        self.assertTrue(self.board.is_square_empty(Location(2, 0)))
+        self.assertFalse(self.board.is_square_empty(Location(0, 3)))
+
+    def test_material_advantage_parity(self):
+        self.assertEqual(self.board.material_advantage(color.white, piece_const.PieceValues()), 0)
+        self.assertEqual(self.board.material_advantage(color.black, piece_const.PieceValues()), 0)
+
+    def test_material_advantage_black_advantage(self):
+        self.board.position[0][0] = None
+
+        self.assertEqual(self.board.material_advantage(color.white, piece_const.PieceValues()), -5)
+        self.assertEqual(self.board.material_advantage(color.black, piece_const.PieceValues()), 5)
+
+        self.board = Board.init_default()
+        self.board.position[0][1] = None
+
+        self.assertEqual(self.board.material_advantage(color.white, piece_const.PieceValues()), -3)
+        self.assertEqual(self.board.material_advantage(color.black, piece_const.PieceValues()), 3)
+
+    def test_material_advantage_white_advantage(self):
+        self.board = Board.init_default()
+        self.board.position[7][0] = None
+
+        self.assertEqual(self.board.material_advantage(color.white, piece_const.PieceValues()), 5)
+        self.assertEqual(self.board.material_advantage(color.black, piece_const.PieceValues()), -5)
+
+        self.board = Board.init_default()
+        self.board.position[7][3] = None
+
+        self.assertEqual(self.board.material_advantage(color.white, piece_const.PieceValues()), 9)
+        self.assertEqual(self.board.material_advantage(color.black, piece_const.PieceValues()), -9)
+
+        self.board = Board.init_default()
+        self.board.position[7][2] = None
+
+        self.assertEqual(self.board.material_advantage(color.white, piece_const.PieceValues()), 3.5)
+        self.assertEqual(self.board.material_advantage(color.black, piece_const.PieceValues()), -3.5)
+
+    def test_advantage_as_result(self):
+        self.assertEqual(self.board.advantage_as_result(converter.long_alg("e2e4", self.board),
+                                                        piece_const.PieceValues()), 0)
+
+        self.board.position[1][3] = None
+        self.assertEqual(
+            self.board.advantage_as_result(converter.long_alg("d1d7", self.board), piece_const.PieceValues()), 0)
+
+        self.board.update(converter.short_alg("e3", color.white, self.board))
+
+        self.assertEqual(
+            self.board.advantage_as_result(
+                converter.short_alg("Bd2", color.white, self.board), piece_const.PieceValues()), -1)
+
+    def test_all_possible_moves_1(self):
+        """
+        Print statement to easily get the list of moves in string form.
+        Used for constructing tests.
+
+        for move in self.board.all_possible_moves(color.white):
+            print("\""+ str(move) + "\", ", end="")
+        """
+        moves = {"b1c3", "b1a3", "g1h3", "g1f3", "a2a3", "a2a4", "b2b3", "b2b4",
+                 "c2c3", "c2c4", "d2d3", "d2d4", "e2e3", "e2e4", "f2f3", "f2f4",
+                 "g2g3", "g2g4", "h2h3", "h2h4"}
+
+        self.assertEqual(moves, {str(move) for move in self.board.all_possible_moves(color.white)})
+
+    def test_all_possible_moves_2(self):
+        self.board.update(converter.long_alg("e2e4", self.board))
+
+        moves = {"a7a6", "a7a5", "b7b6", "b7b5", "c7c6", "c7c5", "d7d6", "d7d5",
+                 "e7e6", "e7e5", "f7f6", "f7f5", "g7g6", "g7g5", "h7h6", "h7h5",
+                 "b8a6", "b8c6", "g8f6", "g8h6"}
+
+        self.assertEqual(moves, {str(move) for move in self.board.all_possible_moves(color.black)})
+
+    def test_no_moves(self):
+        self.assertFalse(self.board.no_moves(color.white))
+        self.assertFalse(self.board.no_moves(color.black))
+
+        # Scholar's Mate
+        self.board.update(converter.short_alg("f4", color.white, self.board))
+        self.board.update(converter.short_alg("e5", color.black, self.board))
+        self.board.update(converter.short_alg("g4", color.white, self.board))
+        self.board.update(converter.short_alg("Qh4", color.black, self.board))
+
+        self.assertTrue(self.board.no_moves(color.white))
+
+    def test_find_piece(self):
+        self.assertEqual(self.board.find_piece(Rook(color.white, Location(0, 0))),
+                         Location(0, 0))
+
+        self.assertEqual(self.board.find_piece(Rook(color.black, Location(7, 0))),
+                         Location(7, 0))
+
+        self.assertNotEqual(self.board.find_piece(Rook(color.black, Location(7, 0))),
+                            Location(3, 0))
+
+        self.assertEqual(self.board.find_piece(Pawn(color.white, Location(0, 0))),
+                         Location.from_string("a2"))
+
+        self.assertEqual(self.board.find_piece(Knight(color.white, Location(0, 0))),
+                         Location.from_string("b1"))
+
+    def test_find_king(self):
+        self.assertEqual(self.board.find_king(color.white),
+                         Location(0, 4))
+
+        self.assertEqual(self.board.find_king(color.black),
+                         Location(7, 4))
+
+    def test_get_king(self):
+        self.assertEqual(self.board.get_king(color.white),
+                         King(color.white, Location(0, 4)))
+
+        self.assertEqual(self.board.get_king(color.black),
+                         King(color.black, Location(7, 4)))
+
+    def test_remove_piece_at_square(self):
+        test_board = Board.init_default()
+        test_board.position[0][0] = None
+        self.board.remove_piece_at_square(Location(0, 0))
+        self.assertEqual(self.board, test_board)
+
+    def test_place_piece_at_square(self):
+        test = Board.init_default()
+        pawn = Pawn(color.white, Location.from_string("e3"))
+
+        test.position[2][4] = pawn
+
+        self.board.place_piece_at_square(pawn, Location.from_string("e3"))
+
+        self.assertEqual(self.board, test)
+
+    def test_move_piece(self):
+        test = Board.init_default()
+        pawn = test.position[1][4]
+        test.position[1][4] = None
+        test.position[3][4] = pawn
+
+        self.board.move_piece(Location.from_string("e2"), Location.from_string("e4"))
+
+        self.assertEqual(self.board, test)
+
+    def test_update_pawn_moves_one_step(self):
+        pawn = self.board.piece_at_square(Location.from_string("e2"))
+        self.board.update(converter.long_alg("e2e3", self.board))
+
+        self.assertIsInstance(pawn, Pawn)
+        self.assertEqual(self.board.piece_at_square(Location.from_string("e3")), pawn)
+        self.assertIsNone(self.board.piece_at_square(Location.from_string("e2")))
+        self.assertFalse(pawn.just_moved_two_steps)
+
+    def test_update_pawn_moves_two_steps(self):
+        pawn = self.board.piece_at_square(Location.from_string("e2"))
+        self.board.update(converter.long_alg("e2e4", self.board))
+
+        self.assertIsInstance(pawn, Pawn)
+        self.assertEqual(self.board.piece_at_square(Location.from_string("e4")), pawn)
+        self.assertIsNone(self.board.piece_at_square(Location.from_string("e2")))
+        self.assertIsNone(self.board.piece_at_square(Location.from_string("e3")))
+        self.assertTrue(pawn.just_moved_two_steps)
+
+        self.board.update(converter.long_alg("d2d4", self.board))
+
+        self.assertFalse(pawn.just_moved_two_steps)
+
+    def test_update_moves_king_side_castle(self):
+        self.board.update(converter.short_alg("e4", color.white, self.board))
+        self.board.update(converter.short_alg("Nf3", color.white, self.board))
+        self.board.update(converter.short_alg("Be2", color.white, self.board))
+        self.board.update(converter.short_alg("o-o", color.white, self.board))
+
+        king = self.board.piece_at_square(Location.from_string("g1"))
+        self.assertIsInstance(king, King)
+        self.assertTrue(king.has_moved)
+
+        rook = self.board.piece_at_square(Location.from_string("f1"))
+        self.assertIsInstance(rook, Rook)
+        self.assertTrue(rook.has_moved)
Index: tests/test_core/test_color.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_core/test_color.py	(date 1547112767000)
+++ tests/test_core/test_color.py	(date 1547112767000)
@@ -0,0 +1,10 @@
+from unittest import TestCase
+
+from chess_py import color
+
+
+class TestColor(TestCase):
+
+    def test_opponent(self):
+        self.assertEqual(-color.white, color.black)
+        self.assertEqual(-color.black, color.white)
Index: tests/test_core/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_core/__init__.py	(date 1547112767000)
+++ tests/test_core/__init__.py	(date 1547112767000)
@@ -0,0 +1,0 @@
Index: tests/test_core/test_algebraic/test_location.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_core/test_algebraic/test_location.py	(date 1547112767000)
+++ tests/test_core/test_algebraic/test_location.py	(date 1547112767000)
@@ -0,0 +1,47 @@
+import unittest
+
+from chess_py import Location
+
+
+class TestLocation(unittest.TestCase):
+
+    def testEquals(self):
+        self.assertEqual(Location(2, 3), Location(2, 3))
+        self.assertEqual(Location(7, 6), Location(7, 6))
+        self.assertNotEqual(Location(4, 5), Location(5, 4))
+
+    def testStr(self):
+        self.assertEqual(str(Location(3, 4)), "e4")
+        self.assertEqual(str(Location(0, 0)), "a1")
+        self.assertEqual(str(Location(7, 7)), "h8")
+
+    def testShiftUp(self):
+        self.assertEqual(Location(3, 4).shift_up(), Location(4, 4))
+        self.assertEqual(Location(0, 2).shift_up(), Location(1, 2))
+
+    def testShiftDown(self):
+        self.assertEqual(Location(3, 4).shift_down(), Location(2, 4))
+        self.assertEqual(Location(1, 2).shift_down(), Location(0, 2))
+
+    def testShiftRight(self):
+        self.assertEqual(Location(3, 4).shift_right(), Location(3, 5))
+        self.assertEqual(Location(0, 2).shift_right(), Location(0, 3))
+
+    def testShiftLeft(self):
+        self.assertEqual(Location(3, 4).shift_left(), Location(3, 3))
+        self.assertEqual(Location(0, 2).shift_left(), Location(0, 1))
+
+    def testShiftUpRight(self):
+        self.assertEqual(Location(3, 4).shift_up_right(), Location(4, 5))
+
+    def testShiftUpLeft(self):
+        self.assertEqual(Location(1, 2).shift_up_left(), Location(2, 1))
+
+    def testShiftDownRight(self):
+        self.assertEqual(Location(5, 3).shift_down_right(), Location(4, 4))
+
+    def testShiftDownLeft(self):
+        self.assertEqual(Location(1, 1).shift_down_left(), Location(0, 0))
+
+if __name__ == '__main__':
+    unittest.main()
Index: tests/test_core/test_algebraic/test_converter.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_core/test_algebraic/test_converter.py	(date 1547112767000)
+++ tests/test_core/test_algebraic/test_converter.py	(date 1547112767000)
@@ -0,0 +1,124 @@
+import unittest
+
+from chess_py import converter, Board, Move, Location, color, notation_const
+from chess_py import Pawn, Knight, Queen, Rook
+
+
+class TestConverter(unittest.TestCase):
+    def setUp(self):
+        self.test_board = Board.init_default()
+        self.e_four_move = Move(end_loc=Location.from_string("e4"),
+                                piece=Pawn(color.white, Location.from_string("e4")),
+                                status=notation_const.MOVEMENT,
+                                start_loc=Location.from_string("e2"))
+
+    def test_short_alg(self):
+        self.assertEqual(converter.short_alg("e4", color.white, self.test_board), self.e_four_move)
+
+    def test_incomplete_alg_pawn_movement(self):
+        self.assertEqual(
+            converter.incomplete_alg("e4", color.white, self.test_board),
+            Move(
+                end_loc=Location.from_string("e4"),
+                piece=Pawn(color.white, Location.from_string("e4")),
+                status=notation_const.MOVEMENT,
+                start_loc=Location.from_string("e2")
+            )
+        )
+
+    def test_incomplete_alg_piece_movement(self):
+        self.assertEqual(
+            converter.incomplete_alg("Nf3", color.white, self.test_board),
+            Move(
+                end_loc=Location.from_string("f3"),
+                piece=Knight(color.white, Location.from_string("f3")),
+                status=notation_const.MOVEMENT,
+                start_loc=Location.from_string("g1")
+            )
+        )
+
+    def test_incomplete_alg_pawn_capture(self):
+        self.test_board.update(converter.short_alg("e4", color.white, self.test_board))
+        self.test_board.update(converter.short_alg("d5", color.black, self.test_board))
+        self.assertEqual(
+            converter.incomplete_alg("exd5", color.white, self.test_board),
+            Move(
+                end_loc=Location.from_string("d5"),
+                piece=Pawn(color.white, Location.from_string("e4")),
+                status=notation_const.CAPTURE,
+                start_loc=Location.from_string("e4")
+            )
+        )
+
+    def test_incomplete_alg_piece_capture(self):
+        self.test_board.update(converter.short_alg("Nf3", color.white, self.test_board))
+        self.test_board.update(converter.short_alg("e5", color.black, self.test_board))
+        self.assertEqual(
+            converter.incomplete_alg("Nxe5", color.white, self.test_board),
+            Move(
+                end_loc=Location.from_string("e5"),
+                piece=Knight(color.white, Location.from_string("f3")),
+                status=notation_const.CAPTURE,
+                start_loc=Location.from_string("f3")
+            )
+        )
+
+    def test_incomplete_alg_pawn_promotion(self):
+        self.test_board.move_piece(Location.from_string("a2"), Location.from_string("a7"))
+        self.test_board.remove_piece_at_square(Location.from_string("a8"))
+        self.assertEqual(
+            converter.incomplete_alg("a8=Q", color.white, self.test_board),
+            Move(
+                end_loc=Location.from_string("a8"),
+                piece=Pawn(color.white, Location.from_string("e7")),
+                status=notation_const.PROMOTE,
+                promoted_to_piece=Queen,
+                start_loc=Location.from_string("a7")
+            )
+        )
+
+    def test_incomplete_alg_piece_movement_with_file_specified(self):
+        self.assertEqual(
+            converter.incomplete_alg("gNf3", color.white, self.test_board),
+            Move(
+                end_loc=Location.from_string("f3"),
+                piece=Knight(color.white, Location.from_string("g1")),
+                status=notation_const.MOVEMENT,
+                start_loc=Location.from_string("g1")
+            )
+        )
+
+    def test_incomplete_alg_piece_movement_with_file_specified_alt(self):
+        self.assertEqual(
+            converter.incomplete_alg("Ngf3", color.white, self.test_board),
+            Move(
+                end_loc=Location.from_string("f3"),
+                piece=Knight(color.white, Location.from_string("g1")),
+                status=notation_const.MOVEMENT,
+                start_loc=Location.from_string("g1")
+            )
+        )
+
+    def test_incomplete_alg_piece_movement_with_rank_and_file_specified(self):
+        self.assertEqual(
+            converter.incomplete_alg("e1Nf3", color.white, self.test_board),
+            Move(
+                end_loc=Location.from_string("f3"),
+                piece=Knight(color.white, Location.from_string("e1")),
+                status=notation_const.MOVEMENT,
+                start_loc=Location.from_string("e1")
+            )
+        )
+
+    def test_incomplete_alg_pawn_promotion_with_capture(self):
+        self.test_board.move_piece(Location.from_string("a2"), Location.from_string("a7"))
+        self.assertEqual(
+            converter.incomplete_alg("axb8=R", color.white, self.test_board),
+            Move(
+                end_loc=Location.from_string("b8"),
+                piece=Pawn(color.white, Location.from_string("a7")),
+                status=notation_const.CAPTURE_AND_PROMOTE,
+                promoted_to_piece=Rook,
+                start_loc=Location.from_string("a7")
+            )
+        )
Index: tests/test_core/test_algebraic/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_core/test_algebraic/__init__.py	(date 1547112767000)
+++ tests/test_core/test_algebraic/__init__.py	(date 1547112767000)
@@ -0,0 +1,0 @@
Index: tests/test_core/test_algebraic/test_move.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_core/test_algebraic/test_move.py	(date 1547112767000)
+++ tests/test_core/test_algebraic/test_move.py	(date 1547112767000)
@@ -0,0 +1,39 @@
+import unittest
+
+from chess_py import Move, Location, notation_const, Pawn, color, Queen
+
+
+class TestMove(unittest.TestCase):
+    def setUp(self):
+        self.white_pawn = Pawn(color.white, Location(1, 0))
+        self.black_pawn = Pawn(color.black, Location(1, 0))
+
+        self.white_pawn_move = Move(Location(2, 0),
+                                    piece=self.white_pawn,
+                                    status=notation_const.MOVEMENT,
+                                    start_loc=Location(1, 0))
+
+        self.start_specified = Move(Location(2, 0),
+                                    piece=self.white_pawn,
+                                    status=notation_const.MOVEMENT,
+                                    start_loc=Location(3, 5))
+
+    def testStr(self):
+        self.assertEqual(str(self.start_specified), "f4a3")
+
+        self.white_pawn_move = Move(Location(7, 0),
+                                    piece=self.white_pawn,
+                                    status=notation_const.MOVEMENT,
+                                    start_loc=Location(6, 0),
+                                    promoted_to_piece=Queen(color.white,
+                                                            Location(7, 0)))
+
+    def testEquals(self):
+        self.assertEqual(self.white_pawn_move, Move(end_loc=Location(2, 0),
+                                                    piece=self.white_pawn,
+                                                    status=notation_const.MOVEMENT,
+                                                    start_loc=Location(1, 0)))
+
+
+if __name__ == '__main__':
+    unittest.main()
Index: tests/test_pieces/test_knight.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_pieces/test_knight.py	(date 1547112767000)
+++ tests/test_pieces/test_knight.py	(date 1547112767000)
@@ -0,0 +1,14 @@
+from unittest import TestCase
+from chess_py import color, Location, Move, Board, Knight
+
+
+class TestKnight(TestCase):
+    def setUp(self):
+        self.empty_pos = Board([[None for _ in range(8)] for _ in range(8)])
+
+    def test_possible_moves(self):
+        self.empty_pos.place_piece_at_square(Knight(color.white, Location.from_string("e4")), Location.from_string("e4"))
+        knight = self.empty_pos.piece_at_square(Location.from_string("e4"))
+
+        moves = knight.possible_moves(self.empty_pos)
+        self.assertEqual(len(list(moves)), 8)
Index: tests/test_pieces/test_pawn.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_pieces/test_pawn.py	(date 1547112767000)
+++ tests/test_pieces/test_pawn.py	(date 1547112767000)
@@ -0,0 +1,107 @@
+from unittest import TestCase
+
+from chess_py.core.algebraic import notation_const
+from chess_py.core import Board
+from chess_py.core.algebraic import Location, Move
+from chess_py.pieces import Queen, Rook, Bishop, Knight, Pawn
+from chess_py import color
+
+
+class TestPawn(TestCase):
+    def setUp(self):
+        self.position = Board.init_default()
+
+        self.white_pawn = Pawn(color.white, Location.from_string("e2"))
+        self.position.place_piece_at_square(self.white_pawn, Location.from_string("e2"))
+
+        self.black_pawn = Pawn(color.black, Location.from_string("a7"))
+        self.position.place_piece_at_square(self.black_pawn, Location.from_string("a7"))
+
+    def test_square_in_front(self):
+        self.assertEqual(self.white_pawn.square_in_front(self.white_pawn.location), Location.from_string("e3"))
+        self.assertEqual(self.black_pawn.square_in_front(self.black_pawn.location), Location.from_string("a6"))
+
+    def test_two_squares_in_front(self):
+        self.assertEqual(self.white_pawn.two_squares_in_front(self.white_pawn.location), Location.from_string("e4"))
+        self.assertEqual(self.black_pawn.two_squares_in_front(self.black_pawn.location), Location.from_string("a5"))
+
+    def test_would_move_be_promotion(self):
+        self.assertTrue(self.white_pawn.would_move_be_promotion(Location.from_string("e7")))
+        self.assertTrue(self.black_pawn.would_move_be_promotion(Location.from_string("a2")))
+        self.assertFalse(self.white_pawn.would_move_be_promotion(Location.from_string("e2")))
+        self.assertFalse(self.black_pawn.would_move_be_promotion(Location.from_string("a7")))
+
+    def test_create_promotion_moves(self):
+        self.white_pawn.location = Location.from_string("e7")
+        moves = list(self.white_pawn.create_promotion_moves(notation_const.CAPTURE,
+                                                            Location.from_string("e7")))
+        self.assertEqual(len(list(moves)), 4)
+        self.assertEqual(moves[0].start_loc, Location.from_string("e7"))
+
+        self.assertEqual(moves[0].promoted_to_piece, Queen)
+        self.assertEqual(moves[1].promoted_to_piece, Rook)
+        self.assertEqual(moves[2].promoted_to_piece, Bishop)
+        self.assertEqual(moves[3].promoted_to_piece, Knight)
+
+    def test_forward_moves(self):
+        self.white_pawn.location = Location.from_string("e2")
+        moves = list(self.white_pawn.forward_moves(self.position))
+
+        self.assertEqual(len(moves), 2)
+        self.assertEqual(moves[0], Move(end_loc=self.white_pawn.square_in_front(self.white_pawn.location),
+                                        piece=self.white_pawn,
+                                        status=notation_const.MOVEMENT,
+                                        start_loc=self.white_pawn.location))
+
+        self.assertEqual(moves[1], Move(end_loc=self.white_pawn.square_in_front(self.white_pawn.square_in_front(self.white_pawn.location)),
+                                        piece=self.white_pawn,
+                                        status=notation_const.MOVEMENT,
+                                        start_loc=self.white_pawn.location))
+
+        moves = list(self.black_pawn.forward_moves(self.position))
+        self.assertEqual(len(moves), 2)
+
+        self.assertEqual(moves[0], Move(end_loc=self.black_pawn.square_in_front(self.black_pawn.location),
+                                        piece=self.black_pawn,
+                                        status=notation_const.MOVEMENT,
+                                        start_loc=self.black_pawn.location))
+
+        self.assertEqual(moves[1], Move(end_loc=self.black_pawn.square_in_front(self.black_pawn.square_in_front(self.black_pawn.location)),
+                                        piece=self.black_pawn,
+                                        status=notation_const.MOVEMENT,
+                                        start_loc=self.black_pawn.location))
+
+    def test_capture_moves(self):
+        self.position.move_piece(Location.from_string("d7"), Location.from_string("d5"))
+        self.position.move_piece(Location.from_string("e2"), Location.from_string("e4"))
+
+        black_pawn = self.position.piece_at_square(Location.from_string("d5"))
+        move = list(self.white_pawn.capture_moves(self.position))
+
+        self.assertEqual(len(move), 1)
+
+        self.assertEqual(move[0], Move(end_loc=black_pawn.location,
+                                       piece=self.white_pawn,
+                                       status=notation_const.CAPTURE,
+                                       start_loc=self.white_pawn.location))
+
+    def test_en_passant_moves(self):
+        self.position.move_piece(Location.from_string("d7"), Location.from_string("d4"))
+        self.position.move_piece(Location.from_string("e2"), Location.from_string("e4"))
+
+        black_pawn = self.position.piece_at_square(Location.from_string("d4"))
+        self.position.piece_at_square(Location.from_string("e4")).just_moved_two_steps = True
+
+        move = list(black_pawn.en_passant_moves(self.position))
+
+        self.assertEqual(len(move), 1)
+        self.assertEqual(move[0], Move(end_loc=black_pawn.square_in_front(black_pawn.location.shift_right()),
+                                       piece=black_pawn,
+                                       status=notation_const.EN_PASSANT,
+                                       start_loc=black_pawn.location))
+
+    def test_possible_moves(self):
+        self.assertEqual(len(list(self.white_pawn.possible_moves(self.position))), 2)
+        self.position.move_piece(Location.from_string("e2"), Location.from_string("e3"))
+        self.assertEqual(len(list(self.white_pawn.possible_moves(self.position))), 1)
+
Index: tests/test_pieces/test_king.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_pieces/test_king.py	(date 1547112767000)
+++ tests/test_pieces/test_king.py	(date 1547112767000)
@@ -0,0 +1,122 @@
+from unittest import TestCase
+from chess_py import color, Location, Move, Board, King, converter, notation_const, Rook
+
+
+class TestKing(TestCase):
+    def setUp(self):
+        self.board = Board.init_default()
+
+    def test_in_check_as_result(self):
+        self.assertFalse(self.board.get_king(color.white).in_check_as_result(self.board,
+                                                 converter.long_alg("e2e4", self.board)))
+
+        self.board.move_piece(Location.from_string("e1"), Location.from_string("e3"))
+        self.board.move_piece(Location.from_string("e8"), Location.from_string("e5"))
+
+        # self.assertTrue(self.board.get_king(color.white).in_check_as_result(self.board, converter.long_alg("e3e4", self.board)))
+
+    def test_add(self):
+        self.assertEqual(
+            len(list(self.board.get_king(color.white).add(lambda  x: x.shift_up(), self.board))),
+            0)
+
+        self.board.update(converter.long_alg("e2e4", self.board))
+
+        # King should be able to move up
+        self.assertEqual(
+            len(list(self.board.get_king(color.white).add(lambda x: x.shift_up(), self.board))),
+            1)
+
+        # King should not be able to move down
+        self.assertEqual(
+            len(list(self.board.get_king(color.white).add(lambda x: x.shift_down(), self.board))),
+            0)
+
+        # King should not be able to move left
+        self.assertEqual(
+            len(list(self.board.get_king(color.white).add(lambda x: x.shift_left(), self.board))),
+            0)
+
+        # King should not be able to move right
+        self.assertEqual(
+            len(list(self.board.get_king(color.white).add(lambda x: x.shift_right(), self.board))),
+            0)
+
+        # King should not be able to move up left
+        self.assertEqual(
+            len(list(self.board.get_king(color.white).add(lambda x: x.shift_up_left(), self.board))),
+            0)
+
+        # King should not be able to move down right
+        self.assertEqual(
+            len(list(self.board.get_king(color.white).add(lambda x: x.shift_down_right(), self.board))),
+            0)
+
+        # King should not be able to move down left
+        self.assertEqual(
+            len(list(self.board.get_king(color.white).add(lambda x: x.shift_down_left(), self.board))),
+            0)
+
+        # King should not be able to move up right
+        self.assertEqual(
+            len(list(self.board.get_king(color.white).add(lambda x: x.shift_up_right(), self.board))),
+            0)
+
+    def test_kingside_castle(self):
+        self.board.update(converter.short_alg("e4", color.white, self.board))
+        self.board.update(converter.short_alg("Nf3", color.white, self.board))
+        self.board.update(converter.short_alg("Be2", color.white, self.board))
+
+        castle_move = Move(
+            end_loc=Location.from_string("g1"),
+            piece=King(color.white, Location.from_string("g1")),
+            status=notation_const.KING_SIDE_CASTLE,
+            start_loc=Location.from_string("e1")
+        )
+
+        self.assertEqual(
+            list(self.board.get_king(color.white).add_castle(self.board))[0], castle_move)
+
+    def test_queenside_castle(self):
+
+        self.board.remove_piece_at_square(Location.from_string("b1"))
+        self.board.remove_piece_at_square(Location.from_string("c1"))
+        self.board.remove_piece_at_square(Location.from_string("d1"))
+
+        castle_move = Move(
+            end_loc=Location.from_string("c1"),
+            piece=King(color.white, Location.from_string("c1")),
+            status=notation_const.QUEEN_SIDE_CASTLE,
+            start_loc=Location.from_string("e1")
+        )
+
+        self.assertEqual(
+            list(self.board.get_king(color.white).add_castle(self.board))[0], castle_move)
+
+    def test_possible_moves(self):
+        self.board = Board([[None for _ in range(8)] for _ in range(8)])
+        my_king = King(color.white, Location.from_string("f3"))
+        self.board.place_piece_at_square(my_king, Location.from_string("f3"))
+        moves = ['f3f4', 'f3g3', 'f3f2', 'f3e3', 'f3g4', 'f3e4', 'f3g2', 'f3e2']
+
+        for i, move in enumerate(my_king.possible_moves(self.board)):
+            self.assertEqual(move, converter.long_alg(moves[i], self.board))
+
+    def test_in_check(self):
+        self.board = Board([[None for _ in range(8)] for _ in range(8)])
+        my_king = King(color.white, Location.from_string("f3"))
+        self.board.place_piece_at_square(my_king, Location.from_string("f3"))
+        self.board.place_piece_at_square(Rook(color.black, Location.from_string("f1")), Location.from_string("f1"))
+
+        print(self.board.piece_at_square(Location.from_string("f1")).color)
+
+        print(self.board)
+        print(my_king.color)
+        print(color.white == color.black)
+        self.assertTrue(my_king.in_check(self.board))
+
+        self.board = Board.init_default()
+        self.board.update(converter.long_alg("f2f3", self.board))
+        self.board.move_piece(Location.from_string("d8"), Location.from_string("g3"))
+
+        self.assertTrue(self.board.get_king(color.white).in_check(self.board))
Index: tests/test_pieces/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_pieces/__init__.py	(date 1547112767000)
+++ tests/test_pieces/__init__.py	(date 1547112767000)
@@ -0,0 +1,0 @@
Index: tests/test_pieces/test_bishop.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/test_pieces/test_bishop.py	(date 1547112767000)
+++ tests/test_pieces/test_bishop.py	(date 1547112767000)
@@ -0,0 +1,37 @@
+from unittest import TestCase
+
+from chess_py import Board, Location, converter
+
+
+class TestBishop(TestCase):
+    def setUp(self):
+        self.board = Board.init_default()
+
+    def test_no_possible_moves(self):
+        self.assertEqual(len(list(self.board.piece_at_square(Location.from_string("c1"))
+                             .possible_moves(self.board))), 0)
+
+    def test_left_diagonal(self):
+        self.board.update(converter.long_alg("b2b3", self.board))
+        moves = list(self.board.piece_at_square(Location.from_string("c1")).possible_moves(self.board))
+
+        self.assertEqual(len(moves), 2)
+        self.assertEqual(moves[0], converter.long_alg("c1b2", self.board))
+        self.assertEqual(moves[1], converter.long_alg("c1a3", self.board))
+
+    def test_capture(self):
+        self.board.move_piece(Location.from_string("g1"), Location.from_string("g7"))
+        moves = list(self.board.piece_at_square(Location.from_string("f8")).possible_moves(self.board))
+
+        self.assertEqual(len(moves), 1)
+        self.assertEqual(moves[0], converter.long_alg("f8g7", self.board))
+
+    def test_possible_moves(self):
+        self.board.move_piece(Location.from_string("c1"), Location.from_string("d4"))
+        test_moves = self.board.piece_at_square(Location.from_string("d4")).possible_moves(self.board)
+        real_moves = ["d4e5", "d4f6", "d4g7", "d4c5", "d4b6", "d4a7", "d4e3", "d4c3"]
+
+        for i, move in enumerate(test_moves):
+            self.assertEqual(str(move), real_moves[i])
+
+
Index: chess_py/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/__init__.py	(date 1547112767000)
+++ chess_py/__init__.py	(date 1547112767000)
@@ -0,0 +1,6 @@
+from .core import *
+from .game import *
+from .pieces import *
+from .players import *
+
+__all__ = core.__all__ + game.__all__ + pieces.__all__ + players.__all__
Index: chess_py/core/board.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/core/board.py	(date 1547148485000)
+++ chess_py/core/board.py	(date 1547148485000)
@@ -0,0 +1,427 @@
+# -*- coding: utf-8 -*-
+
+"""
+Constructs board object which stores the get_location of all the pieces.
+
+Default Array
+
+| [[0th row 0th item,  0th row 1st item,  0th row 2nd item],
+|  [1st row 0th item,  1st row 1st item,  1st row 2nd item],
+|  [2nd row 0th item, 2nd row 1st item,  2nd row 2nd item]]
+
+| Default board
+| 8 ║♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜ Black pieces
+| 7 ║♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟ Black pawns
+| 6 ║a6… … … … … …h6
+| 5 ║… … … … … … … …
+| 4 ║… … … … … … … …
+| 3 ║a3… … … … … …h3 Algebraic
+| 2 ║♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙ White pawns
+| 1 ║♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖ White pieces
+| -—╚═══════════════
+| ——-a b c d e f g h
+
+Pieces on the board are flipped in position array so white home row is at index 0
+and black home row is at index 7
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+from __future__ import print_function
+
+import inspect
+from multiprocessing import Process
+from copy import copy as cp
+from math import fabs
+
+from .color import white, black
+from .algebraic import notation_const
+from .algebraic.location import Location
+from .algebraic.move import Move
+from ..pieces.piece import Piece
+from ..pieces.bishop import Bishop
+from ..pieces.king import King
+from ..pieces.pawn import Pawn
+from ..pieces.queen import Queen
+from ..pieces.rook import Rook
+from ..pieces.knight import Knight
+
+
+class Board:
+    """
+    Standard starting position in a chess game.
+    Initialized upon startup and is used when init_default constructor is used
+
+    """
+
+    def __init__(self, position):
+        """
+        Creates a ``Board`` given an array of ``Piece`` and ``None``
+        objects to represent the given position of the board.
+
+        :type: position: list
+        """
+        self.position = position
+        self.possible_moves = dict()
+        try:
+            self.king_loc_dict = {white: self.find_king(white),
+                                  black: self.find_king(black)}
+        except ValueError:
+            self.king_loc_dict = None
+
+    @classmethod
+    def init_default(cls):
+        """
+        Creates a ``Board`` with the standard chess starting position.
+
+        :rtype: Board
+        """
+        return cls([
+
+            # First rank
+            [Rook(white, Location(0, 0)), Knight(white, Location(0, 1)), Bishop(white, Location(0, 2)),
+             Queen(white, Location(0, 3)), King(white, Location(0, 4)), Bishop(white, Location(0, 5)),
+             Knight(white, Location(0, 6)), Rook(white, Location(0, 7))],
+
+            # Second rank
+            [Pawn(white, Location(1, file)) for file in range(8)],
+
+            # Third rank
+            [None for _ in range(8)],
+
+            # Fourth rank
+            [None for _ in range(8)],
+
+            # Fifth rank
+            [None for _ in range(8)],
+
+            # Sixth rank
+            [None for _ in range(8)],
+
+            # Seventh rank
+            [Pawn(black, Location(6, file)) for file in range(8)],
+
+            # Eighth rank
+            [Rook(black, Location(7, 0)), Knight(black, Location(7, 1)), Bishop(black, Location(7, 2)),
+             Queen(black, Location(7, 3)), King(black, Location(7, 4)), Bishop(black, Location(7, 5)),
+             Knight(black, Location(7, 6)), Rook(black, Location(7, 7))]
+        ])
+
+    @property
+    def position_tuple(self):
+        return ((str(piece) for piece in self.position[index]) for index, row in enumerate(self.position))
+
+    def __key(self):
+        return self.position
+
+    def __hash__(self):
+        return hash(tuple([hash(piece) for piece in self]))
+
+    def __eq__(self, other):
+        if not isinstance(other, self.__class__):
+            raise TypeError("Cannot compare other type to Board")
+
+        for i, row in enumerate(self.position):
+            for j, piece in enumerate(row):
+
+                if piece != other.position[i][j]:
+                    return False
+
+        return True
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def __str__(self):
+        board_string = ""
+        for i, row in enumerate(self.position):
+            board_string += str(8 - i) + " "
+            for j, square in enumerate(row):
+
+                piece = self.piece_at_square(Location(7 - i, j))
+                if isinstance(piece, Piece):
+                    board_string += piece.symbol + " "
+                else:
+                    board_string += "_ "
+
+            board_string += "\n"
+
+        board_string += "  a b c d e f g h"
+        return board_string
+
+    def __iter__(self):
+        for row in self.position:
+            for square in row:
+                yield square
+
+    def __copy__(self):
+        """
+        Copies the board faster than deepcopy
+
+        :rtype: Board
+        """
+        return Board([[cp(piece) or None
+                       for piece in self.position[index]]
+                      for index, row in enumerate(self.position)])
+
+    def piece_at_square(self, location):
+        """
+        Finds the chess piece at a square of the position.
+
+        :type: location: Location
+        :rtype: Piece
+        """
+        return self.position[location.rank][location.file]
+
+    def is_square_empty(self, location):
+        """
+        Finds whether a chess piece occupies a square of the position.
+
+        :type: location: Location
+        :rtype: bool
+        """
+        return self.position[location.rank][location.file] is None
+
+    def material_advantage(self, input_color, val_scheme):
+        """
+        Finds the advantage a particular side possesses given a value scheme.
+
+        :type: input_color: Color
+        :type: val_scheme: PieceValues
+        :rtype: double
+        """
+
+        if self.get_king(input_color).in_check(self) and self.no_moves(input_color):
+            return -100
+
+        if self.get_king(-input_color).in_check(self) and self.no_moves(-input_color):
+            return 100
+
+        return sum([val_scheme.val(piece, input_color) for piece in self])
+
+    def advantage_as_result(self, move, val_scheme):
+        """
+        Calculates advantage after move is played
+
+        :type: move: Move
+        :type: val_scheme: PieceValues
+        :rtype: double
+        """
+        test_board = cp(self)
+        test_board.update(move)
+        return test_board.material_advantage(move.color, val_scheme)
+
+    def all_possible_moves(self, input_color):
+        """
+        Checks if all the possible moves has already been calculated
+        and is stored in `possible_moves` dictionary. If not, it is calculated
+        with `_calc_all_possible_moves`.
+        
+        :type: input_color: Color
+        :rtype: list
+        """
+        position_tuple = self.position_tuple
+        if position_tuple not in self.possible_moves:
+            self.possible_moves[position_tuple] = tuple(self._calc_all_possible_moves(input_color))
+
+        return self.possible_moves[position_tuple]
+
+    def _calc_all_possible_moves(self, input_color):
+        """
+        Returns list of all possible moves
+
+        :type: input_color: Color
+        :rtype: list
+        """
+        for piece in self:
+
+            # Tests if square on the board is not empty
+            if piece is not None and piece.color == input_color:
+
+                for move in piece.possible_moves(self):
+
+                    test = cp(self)
+                    test_move = Move(end_loc=move.end_loc,
+                                     piece=test.piece_at_square(move.start_loc),
+                                     status=move.status,
+                                     start_loc=move.start_loc,
+                                     promoted_to_piece=move.promoted_to_piece)
+                    test.update(test_move)
+
+                    if self.king_loc_dict is None:
+                        yield move
+                        continue
+
+                    my_king = test.piece_at_square(self.king_loc_dict[input_color])
+
+                    if my_king is None or \
+                            not isinstance(my_king, King) or \
+                            my_king.color != input_color:
+                        self.king_loc_dict[input_color] = test.find_king(input_color)
+                        my_king = test.piece_at_square(self.king_loc_dict[input_color])
+
+                    if not my_king.in_check(test):
+                        yield move
+
+    def runInParallel(*fns):
+        """
+        Runs multiple processes in parallel.
+
+        :type: fns: def
+        """
+        proc = []
+        for fn in fns:
+            p = Process(target=fn)
+            p.start()
+            proc.append(p)
+        for p in proc:
+            p.join()
+
+    def no_moves(self, input_color):
+
+        # Loops through columns
+        for piece in self:
+
+            # Tests if square on the board is not empty
+            if piece is not None and piece.color == input_color:
+
+                for move in piece.possible_moves(self):
+
+                    test = cp(self)
+                    test.update(move)
+
+                    if not test.get_king(input_color).in_check(test):
+                        return False
+
+        return True
+
+    def find_piece(self, piece):
+        """
+        Finds Location of the first piece that matches piece.
+        If none is found, Exception is raised.
+
+        :type: piece: Piece
+        :rtype: Location
+        """
+        for i, _ in enumerate(self.position):
+            for j, _ in enumerate(self.position):
+                loc = Location(i, j)
+
+                if not self.is_square_empty(loc) and \
+                        self.piece_at_square(loc) == piece:
+                    return loc
+
+        raise ValueError("{} \nPiece not found: {}".format(self, piece))
+
+    def get_piece(self, piece_type, input_color):
+        """
+        Gets location of a piece on the board given the type and color.
+        
+        :type: piece_type: Piece
+        :type: input_color: Color 
+        :rtype: Location
+        """
+        for loc in self:
+            piece = self.piece_at_square(loc)
+
+            if not self.is_square_empty(loc) and \
+                    isinstance(piece, piece_type) and \
+                    piece.color == input_color:
+                return loc
+
+        raise Exception("{} \nPiece not found: {}".format(self, piece_type))
+
+    def find_king(self, input_color):
+        """
+        Finds the Location of the King of input_color
+
+        :type: input_color: Color
+        :rtype: Location
+        """
+        return self.find_piece(King(input_color, Location(0, 0)))
+
+    def get_king(self, input_color):
+        """
+        Returns King of input_color
+
+        :type: input_color: Color
+        :rtype: King
+        """
+        return self.piece_at_square(self.find_king(input_color))
+
+    def remove_piece_at_square(self, location):
+        """
+        Removes piece at square
+
+        :type: location: Location
+        """
+        self.position[location.rank][location.file] = None
+
+    def place_piece_at_square(self, piece, location):
+        """
+        Places piece at given get_location
+
+        :type: piece: Piece
+        :type: location: Location
+        """
+        self.position[location.rank][location.file] = piece
+        piece.location = location
+
+    def move_piece(self, initial, final):
+        """
+        Moves piece from one location to another
+
+        :type: initial: Location
+        :type: final: Location
+        """
+        self.place_piece_at_square(self.piece_at_square(initial), final)
+        self.remove_piece_at_square(initial)
+
+    def update(self, move):
+        """
+        Updates position by applying selected move
+
+        :type: move: Move
+        """
+        if move is None:
+            raise TypeError("Move cannot be type None")
+
+        if self.king_loc_dict is not None and isinstance(move.piece, King):
+            self.king_loc_dict[move.color] = move.end_loc
+
+        # Invalidates en-passant
+        for square in self:
+            pawn = square
+            if isinstance(pawn, Pawn):
+                pawn.just_moved_two_steps = False
+
+        # Sets King and Rook has_moved property to True is piece has moved
+        if type(move.piece) is King or type(move.piece) is Rook:
+            move.piece.has_moved = True
+
+        elif move.status == notation_const.MOVEMENT and \
+                isinstance(move.piece, Pawn) and \
+                fabs(move.end_loc.rank - move.start_loc.rank) == 2:
+            move.piece.just_moved_two_steps = True
+
+        if move.status == notation_const.KING_SIDE_CASTLE:
+            self.move_piece(Location(move.end_loc.rank, 7), Location(move.end_loc.rank, 5))
+            self.piece_at_square(Location(move.end_loc.rank, 5)).has_moved = True
+
+        elif move.status == notation_const.QUEEN_SIDE_CASTLE:
+            self.move_piece(Location(move.end_loc.rank, 0), Location(move.end_loc.rank, 3))
+            self.piece_at_square(Location(move.end_loc.rank, 3)).has_moved = True
+
+        elif move.status == notation_const.EN_PASSANT:
+            self.remove_piece_at_square(Location(move.start_loc.rank, move.end_loc.file))
+
+        elif move.status == notation_const.PROMOTE or \
+                move.status == notation_const.CAPTURE_AND_PROMOTE:
+            try:
+                self.remove_piece_at_square(move.start_loc)
+                self.place_piece_at_square(move.promoted_to_piece(move.color, move.end_loc), move.end_loc)
+            except TypeError as e:
+                raise ValueError("Promoted to piece cannot be None in Move {}\n{}".format(repr(move), e))
+            return
+
+        self.move_piece(move.piece.location, move.end_loc)
Index: chess_py/core/color.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/core/color.py	(date 1547148489000)
+++ chess_py/core/color.py	(date 1547148489000)
@@ -0,0 +1,79 @@
+# -*- coding: utf-8 -*-
+
+"""
+Easy way to access bool values for black and white without directly
+typing True or False.
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+
+class Color:
+
+    _color_dict = {
+        'white': True,
+        'black': False,
+    }
+
+    def __init__(self, raw):
+        """
+        Initializes new color using a boolean
+        True is white and False is black
+
+        :type: raw: bool
+        """
+        self._bool = raw
+
+    @classmethod
+    def from_string(cls, string):
+        """
+        Converts string "white" or "black" into
+        corresponding color
+
+        :type: string: str
+        :rtype: Color
+        """
+        return cls(cls._color_dict[string])
+
+    def __repr__(self):
+        return "color.{}".format(str(self))
+
+    def __str__(self):
+        if self._bool:
+            return "white"
+        else:
+            return "black"
+
+    def __bool__(self):
+        return self._bool
+
+    def __int__(self):
+        if self._bool:
+            return 1
+        else:
+            return -1
+
+    def __key(self):
+        return bool(self)
+
+    def __hash__(self):
+        return hash(self.__key())
+
+    def __neg__(self):
+        return Color(not self._bool)
+
+    def __eq__(self, other):
+        """
+        Finds out this color is the same as another color.
+
+        :type: other: Color
+        :rtype: bool
+        """
+        return bool(self) == bool(other)
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+
+white = Color(True)
+black = Color(False)
Index: chess_py/core/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/core/__init__.py	(date 1547112767000)
+++ chess_py/core/__init__.py	(date 1547112767000)
@@ -0,0 +1,6 @@
+from . import algebraic, color
+from .algebraic import Move, Location
+from .algebraic import converter, notation_const
+from .board import Board
+
+__all__ = ['Board', 'color'] + algebraic.__all__
Index: chess_py/core/algebraic/notation_const.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/core/algebraic/notation_const.py	(date 1547148521000)
+++ chess_py/core/algebraic/notation_const.py	(date 1547148521000)
@@ -0,0 +1,26 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class stores integer values for various types of moves in algebraic notation.
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+
+MOVEMENT = 0
+
+CAPTURE = 1
+
+KING_SIDE_CASTLE = 2
+
+QUEEN_SIDE_CASTLE = 3
+
+EN_PASSANT = 4
+
+PROMOTE = 5
+
+CAPTURE_AND_PROMOTE = 6
+
+NOT_IMPLEMENTED = 7
+
+LONG_ALG = 8
Index: chess_py/core/algebraic/move.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/core/algebraic/move.py	(date 1547148513000)
+++ chess_py/core/algebraic/move.py	(date 1547148513000)
@@ -0,0 +1,125 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class that stores chess moves.
+Destination, status and piece making move are required
+to initialize Move.
+
+:type: end_loc: Location
+:type: piece: Piece
+:type: status: int
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+from .location import Location
+
+
+class Move:
+    def __init__(self,
+                 end_loc,
+                 piece,
+                 status,
+                 start_loc,
+                 promoted_to_piece=None):
+        """
+        Constructor to create move using ``Location``
+
+        :type: end_loc: Location
+        :type: piece: Piece
+        :type: status: int
+        """
+        self._end_loc = end_loc
+        self._status = status
+        self._piece = piece
+        self._start_loc = start_loc
+        self.color = piece.color
+        self.promoted_to_piece = promoted_to_piece
+
+    @property
+    def end_loc(self):
+        return self._end_loc
+
+    @property
+    def status(self):
+        return self._status
+
+    @property
+    def piece(self):
+        return self._piece
+
+    def __key(self):
+        return self.end_loc, \
+               self.piece, \
+               self.status, \
+               self.start_loc, \
+               self.promoted_to_piece
+
+    def __hash__(self):
+        return hash(self.__key())
+
+    def __eq__(self, other):
+        """
+        Finds if move is same move as this one.
+        :type: other: Move
+        """
+        if not isinstance(other, self.__class__):
+            raise TypeError("Cannot compare type {} with Move".format(type(other)))
+
+        for index, item in enumerate(self.__key()):
+            if not self._check_equals_or_none(item, other.__key()[index]):
+                return False
+
+        return True
+
+    @staticmethod
+    def _check_equals_or_none(var1, var2):
+        """
+        If either is None then return True,
+        otherwise compare them and return
+        if they are equal.
+
+        :type: var1: object
+        :type: var2: object
+        :rtype: bool
+        """
+        if var1 is None or var2 is None:
+            return True
+
+        return var1 == var2
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def __repr__(self):
+        return "Move({})".format(self.__dict__)
+
+    def __str__(self):
+        """
+        Finds string representation in long algebraic notation
+
+        :rtype: str
+        """
+        move_str = str(self._start_loc) + str(self._end_loc)
+
+        if self.promoted_to_piece is not None:
+            move_str += str(self.promoted_to_piece)
+
+        return move_str
+
+    @property
+    def start_loc(self):
+        """
+        Finds start Location of move if specified.
+        Otherwise throws an AttributeError
+
+        :rtype: Location
+        """
+        return self._start_loc
+
+    def would_move_be_promotion(self):
+        """
+        Finds if move from current location would be a promotion
+        """
+        return (self._end_loc.rank == 0 and not self.color) or \
+            (self._end_loc.rank == 7 and self.color)
Index: chess_py/core/algebraic/location.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/core/algebraic/location.py	(date 1547148507000)
+++ chess_py/core/algebraic/location.py	(date 1547148507000)
@@ -0,0 +1,265 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class stores Locations on the Board in form ``Location(rank, file)``.
+
+| rank - y coordinate from 0 to 7
+| file - x coordinate from 0 to 7
+
+Can be initialized with coordinates not
+on the chess board, however, such locations
+will not work properly with other classes
+such as ``Board``.
+
+Location is immutable.
+
+Examples (shown on board below):
+
+| a = Location(0, 0)
+| b = Location(7, 7)
+| c = Location(3, 4)
+
+| rank
+| 7 8 ║… … … … … … … b
+| 6 7 ║… … … … … … … …
+| 5 6 ║… … … … … … … …
+| 4 5 ║… … … … … … … …
+| 3 4 ║… … … … c … … …
+| 2 3 ║… … … … … … … …
+| 1 2 ║… … … … … … … …
+| 0 1 ║a … … … … … … …
+| ----╚═══════════════
+| ——---a b c d e f g h
+| -----0 1 2 3 4 5 6 7
+| ------file
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+from .. import color
+
+class Direction:
+    UP = 0
+    RIGHT = 1
+    DOWN = 2
+    LEFT = 3
+
+
+class Location:
+    def __init__(self, rank, file):
+        """
+        Creates a location on a chessboard given x and y coordinates.
+
+        :type: rank: int
+        :type: file: int
+        """
+        if rank < 0 or rank > 7 or file < 0 or file > 7:
+            raise IndexError("Location must be on the board")
+
+        self._rank = rank
+        self._file = file
+
+    @classmethod
+    def from_string(cls, alg_str):
+        """
+        Creates a location from a two character string consisting of 
+        the file then rank written in algebraic notation.
+        
+        Examples: e4, b5, a7
+
+        :type: alg_str: str
+        :rtype: Location
+        """
+        try:
+            return cls(int(alg_str[1]) - 1, ord(alg_str[0]) - 97)
+        except ValueError as e:
+            raise ValueError("Location.from_string {} invalid: {}".format(alg_str, e))
+
+    @property
+    def rank(self):
+        return self._rank
+
+    @property
+    def file(self):
+        return self._file
+
+    def __key(self):
+        return self.rank, self.file
+
+    def __hash__(self):
+        return hash(self.__key())
+
+    def __eq__(self, other):
+        """
+        Tests to see if both locations
+        are the same ie rank and file is 
+        the same.
+
+        :type: other: Location
+        """
+        if not isinstance(other, self.__class__):
+            raise TypeError("Cannot compare other types with Location")
+
+        return int(self.rank) == int(other.rank) and \
+            int(self.file) == int(other.file)
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def __repr__(self):
+        return "Location({}, {} ({}))".format(self._rank, self._file, str(self))
+
+    def __str__(self):
+        """
+        Finds string representation of Location in algebraic form ie "e4"
+
+        :rtype: str
+        """
+        if self._rank is None:
+            rank_str = ""
+        else:
+            rank_str = str(self._rank + 1)
+
+        if self._file is None:
+            file_str = ""
+        else:
+            file_str = chr(self._file + 97)
+
+        return file_str + rank_str
+
+    def on_board(self):
+        """
+        Returns if the move is on the board or not.
+        If the rank and file are both in between
+        0 and 7, this method will return True.
+
+        :rtype: bool
+        """
+        if -1 < self._rank < 8 and \
+                -1 < self._file < 8:
+            return True
+
+        return False
+
+    def shift(self, direction):
+        """
+        Shifts in direction provided by ``Direction`` enum.
+
+        :type: direction: Direction
+        :rtype: Location
+        """
+        try:
+            if direction == Direction.UP:
+                return self.shift_up()
+            elif direction == Direction.DOWN:
+                return self.shift_down()
+            elif direction == Direction.RIGHT:
+                return self.shift_right()
+            elif direction == Direction.LEFT:
+                return self.shift_left()
+            else:
+                raise IndexError("Invalid direction {}".format(direction))
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_up(self, times=1):
+        """
+        Finds Location shifted up by 1
+
+        :rtype: Location
+        """
+        try:
+            return Location(self._rank + times, self._file)
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_down(self, times=1):
+        """
+        Finds Location shifted down by 1
+
+        :rtype: Location
+        """
+        try:
+            return Location(self._rank - times, self._file)
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_forward(self, ref_color, times=1):
+        direction = 1 if ref_color == color.white else -1
+        try:
+            return Location(self._rank + times*direction, self._file)
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_back(self, ref_color, times=1):
+        direction = -1 if ref_color == color.white else 1
+        try:
+            return Location(self._rank + times*direction, self._file)
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_right(self, times=1):
+        """
+        Finds Location shifted right by 1
+
+        :rtype: Location
+        """
+        try:
+            return Location(self._rank, self._file + times)
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_left(self, times=1):
+        """
+        Finds Location shifted left by 1
+
+        :rtype: Location
+        """
+        try:
+            return Location(self._rank, self._file - times)
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_up_right(self, times=1):
+        """
+        Finds Location shifted up right by 1
+
+        :rtype: Location
+        """
+        try:
+            return Location(self._rank + times, self._file + times)
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_up_left(self, times=1):
+        """
+        Finds Location shifted up left by 1
+
+        :rtype: Location
+        """
+        try:
+            return Location(self._rank + times, self._file - times)
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_down_right(self, times=1):
+        """
+        Finds Location shifted down right by 1
+
+        :rtype: Location
+        """
+        try:
+            return Location(self._rank - times, self._file + times)
+        except IndexError as e:
+            raise IndexError(e)
+
+    def shift_down_left(self, times=1):
+        """
+        Finds Location shifted down left by 1
+
+        :rtype: Location
+        """
+        try:
+            return Location(self._rank - times, self._file - times)
+        except IndexError as e:
+            raise IndexError(e)
Index: chess_py/core/algebraic/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/core/algebraic/__init__.py	(date 1547112767000)
+++ chess_py/core/algebraic/__init__.py	(date 1547112767000)
@@ -0,0 +1,4 @@
+from .location import Location, Direction
+from .move import Move
+
+__all__ = ['converter', 'Location', 'Move', 'notation_const']
Index: chess_py/core/algebraic/converter.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/core/algebraic/converter.py	(date 1547148498000)
+++ chess_py/core/algebraic/converter.py	(date 1547148498000)
@@ -0,0 +1,383 @@
+# -*- coding: utf-8 -*-
+
+"""
+Methods that take external input and attempt
+to turn them into usable commands.
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+from copy import copy as cp
+
+from .. import color
+from . import notation_const
+from .location import Location
+from .move import Move
+from ..board import Board
+from ...pieces.bishop import Bishop
+from ...pieces.king import King
+from ...pieces.pawn import Pawn
+from ...pieces.queen import Queen
+from ...pieces.rook import Rook
+from ...pieces.knight import Knight
+
+
+def _get_piece(string, index):
+    """
+    Returns Piece subclass given index of piece.
+
+    :type: index: int
+    :type: loc Location
+
+    :raise: KeyError
+    """
+    piece = string[index].strip()
+    piece = piece.upper()
+    piece_dict = {'R': Rook,
+                  'P': Pawn,
+                  'B': Bishop,
+                  'N': Knight,
+                  'Q': Queen,
+                  'K': King}
+    try:
+        return piece_dict[piece]
+    except KeyError:
+        raise ValueError("Piece {} is invalid".format(piece))
+
+
+def _get_piece_start_location(end_location,
+                              input_color,
+                              piece_in_move,
+                              position,
+                              start_rank=None,
+                              start_file=None):
+    try:
+        start_rank = int(start_rank) - 1
+    except TypeError:
+        pass
+    try:
+        start_file = ord(start_file) - 97
+    except TypeError:
+        pass
+
+    def _is_at_start_rank_and_file(potential_start):
+        if start_rank is not None and start_file is not None:
+            return start_rank == potential_start.rank and \
+                   start_file == potential_start.file
+        elif start_rank is not None:
+            return start_rank == potential_start.rank
+        elif start_file is not None:
+            return start_file == potential_start.file
+        else:
+            return True
+
+    def _is_valid_move_option(move):
+        real_piece = position.piece_at_square(move.end_loc)
+        return type(real_piece) is piece_in_move and \
+            real_piece.color == input_color and \
+            _is_at_start_rank_and_file(move.end_loc)
+
+    test_piece = piece_in_move(input_color, end_location)
+    empty_board = Board([[None for _ in range(8)] for _ in range(8)])
+    empty_board_valid_moves = [move for move in test_piece.possible_moves(empty_board)
+                               if _is_valid_move_option(move)]
+
+    if len(empty_board_valid_moves) == 1:
+        return position.piece_at_square(empty_board_valid_moves[0].end_loc), \
+               empty_board_valid_moves[0].end_loc
+    else:
+        for empty_board_move in empty_board_valid_moves:
+            poss_piece = position.piece_at_square(empty_board_move.end_loc)
+            for real_board_move in poss_piece.possible_moves(position):
+                test_in_check_board = cp(position)
+                test_move = Move(end_loc=real_board_move.end_loc,
+                                 piece=test_in_check_board.piece_at_square(real_board_move.start_loc),
+                                 status=real_board_move.status,
+                                 start_loc=real_board_move.start_loc,
+                                 promoted_to_piece=real_board_move.promoted_to_piece)
+                test_in_check_board.update(test_move)
+                if real_board_move.end_loc == end_location and \
+                        not test_in_check_board.get_king(input_color).in_check(test_in_check_board):
+                    return poss_piece, real_board_move.start_loc
+
+    raise ValueError("No valid piece move found")
+
+
+def incomplete_alg(alg_str, input_color, position):
+    """
+    Converts a string written in short algebraic form into an incomplete move.
+    These incomplete moves do not have the initial location specified and
+    therefore cannot be used to update the board. IN order to fully utilize
+    incomplete move, it must be run through ``make_legal()`` with
+    the corresponding position. It is recommended to use
+    ``short_alg()`` instead of this method because it returns a complete
+    move.
+
+    Examples: e4, Nf3, exd5, Qxf3, 00, 000, e8=Q
+
+    :type: alg_str: str
+    :type: input_color: Color
+    """
+    edge_rank = 0 \
+        if input_color == color.white \
+        else 7
+
+    if alg_str is None or len(alg_str) <= 1:
+        raise ValueError("algebraic string {} is invalid".format(alg_str))
+
+    # King-side castle
+    if alg_str in ["00", "oo", "OO", "0-0", "o-o", "O-O"]:
+        return Move(end_loc=Location(edge_rank, 6),
+                    piece=King(input_color, Location(edge_rank, 4)),
+                    status=notation_const.KING_SIDE_CASTLE,
+                    start_loc=Location(edge_rank, 4))
+
+    # Queen-side castle
+    if alg_str in ["000", "ooo", "OOO", "0-0-0", "o-o-o", "O-O-O"]:
+        return Move(end_loc=Location(edge_rank, 2),
+                    piece=King(input_color, Location(edge_rank, 4)),
+                    status=notation_const.QUEEN_SIDE_CASTLE,
+                    start_loc=Location(edge_rank, 4))
+    try:
+        end_location = Location.from_string(alg_str[-2:])
+    except ValueError:
+        end_location = Location.from_string(alg_str[-4:-2])
+
+    # Pawn movement
+    if len(alg_str) == 2:
+        possible_pawn = position.piece_at_square(end_location.shift_back(input_color))
+        if type(possible_pawn) is Pawn and \
+                possible_pawn.color == input_color:
+            start_location = end_location.shift_back(input_color)
+        else:
+            start_location = end_location.shift_back(input_color, times=2)
+        return Move(end_loc=end_location,
+                    piece=position.piece_at_square(start_location),
+                    status=notation_const.MOVEMENT,
+                    start_loc=start_location)
+
+    # Non-pawn Piece movement
+    if len(alg_str) == 3:
+        possible_piece, start_location = _get_piece_start_location(end_location,
+                                                                   input_color,
+                                                                   _get_piece(alg_str, 0),
+                                                                   position)
+        return Move(end_loc=end_location,
+                    piece=possible_piece,
+                    status=notation_const.MOVEMENT,
+                    start_loc=start_location)
+
+    # Multiple options (Capture or Piece movement with file specified)
+    if len(alg_str) == 4:
+
+        # Capture
+        if alg_str[1].upper() == "X":
+
+            # Pawn capture
+            if not alg_str[0].isupper():
+                pawn_location = Location(end_location.rank, ord(alg_str[0]) - 97).shift_back(input_color)
+                possible_pawn = position.piece_at_square(pawn_location)
+                if type(possible_pawn) is Pawn and \
+                        possible_pawn.color == input_color:
+                    en_passant_pawn = position.piece_at_square(end_location.shift_back(input_color))
+                    if type(en_passant_pawn) is Pawn and \
+                            en_passant_pawn.color != input_color and \
+                            position.is_square_empty(end_location):
+                        return Move(end_loc=end_location,
+                                    piece=position.piece_at_square(pawn_location),
+                                    status=notation_const.EN_PASSANT,
+                                    start_loc=pawn_location)
+                    else:
+                        return Move(end_loc=end_location,
+                                    piece=position.piece_at_square(pawn_location),
+                                    status=notation_const.CAPTURE,
+                                    start_loc=pawn_location)
+
+            # Piece capture
+            elif alg_str[0].isupper():
+                possible_piece, start_location = _get_piece_start_location(end_location,
+                                                                           input_color,
+                                                                           _get_piece(alg_str, 0),
+                                                                           position)
+                return Move(end_loc=end_location,
+                            piece=possible_piece,
+                            status=notation_const.CAPTURE,
+                            start_loc=start_location)
+
+        # Pawn Promotion
+        elif alg_str[2] == "=":
+            promote_end_loc = Location.from_string(alg_str[:2])
+            if promote_end_loc.rank != 0 and promote_end_loc.rank != 7:
+                raise ValueError("Promotion {} must be on the last rank".format(alg_str))
+            return Move(end_loc=promote_end_loc,
+                        piece=Pawn(input_color, promote_end_loc),
+                        status=notation_const.PROMOTE,
+                        promoted_to_piece=_get_piece(alg_str, 3),
+                        start_loc=promote_end_loc.shift_back(input_color))
+
+        # Non-pawn Piece movement with file specified (aRb7)
+        elif alg_str[1].isupper() and not alg_str[0].isdigit():
+            possible_piece, start_location = _get_piece_start_location(end_location,
+                                                                       input_color,
+                                                                       _get_piece(alg_str, 1),
+                                                                       position,
+                                                                       start_file=alg_str[0])
+            return Move(end_loc=end_location,
+                        piece=possible_piece,
+                        status=notation_const.MOVEMENT,
+                        start_loc=start_location)
+
+        # (alt) Non-pawn Piece movement with file specified (Rab7)
+        elif alg_str[0].isupper() and not alg_str[1].isdigit():
+            possible_piece, start_location = _get_piece_start_location(end_location,
+                                                                       input_color,
+                                                                       _get_piece(alg_str, 0),
+                                                                       position,
+                                                                       start_file=alg_str[1])
+            return Move(end_loc=end_location,
+                        piece=possible_piece,
+                        status=notation_const.MOVEMENT,
+                        start_loc=start_location)
+
+        # Non-pawn Piece movement with rank specified (R1b7)
+        elif alg_str[0].isupper() and alg_str[1].isdigit():
+            possible_piece, start_location = _get_piece_start_location(end_location,
+                                                                       input_color,
+                                                                       _get_piece(alg_str, 0),
+                                                                       position,
+                                                                       start_rank=alg_str[1])
+            return Move(end_loc=end_location,
+                        piece=possible_piece,
+                        status=notation_const.MOVEMENT,
+                        start_loc=start_location)
+
+    # Multiple options
+    if len(alg_str) == 5:
+
+        # Non-pawn Piece movement with rank and file specified (a2Ra1
+        if not alg_str[0].isdigit() and \
+                alg_str[1].isdigit() and \
+                alg_str[2].isupper() and \
+                not alg_str[3].isdigit() and \
+                alg_str[4].isdigit:
+            start_loc = Location.from_string(alg_str[:2])
+            return Move(end_loc=end_location,
+                        piece=_get_piece(alg_str, 2)(input_color, end_location),
+                        status=notation_const.MOVEMENT,
+                        start_loc=start_loc)
+
+        # Multiple Piece capture options
+        if alg_str[2].upper() == "X":
+
+            # Piece capture with rank specified (R1xa1)
+            if alg_str[1].isdigit():
+                possible_piece, start_location = _get_piece_start_location(end_location,
+                                                                           input_color,
+                                                                           _get_piece(alg_str, 0),
+                                                                           position,
+                                                                           start_rank=alg_str[1])
+                return Move(end_loc=end_location,
+                            piece=possible_piece,
+                            status=notation_const.CAPTURE,
+                            start_loc=start_location)
+
+            # Piece capture with file specified (Rdxd7)
+            else:
+                possible_piece, start_location = _get_piece_start_location(end_location,
+                                                                           input_color,
+                                                                           _get_piece(alg_str, 0),
+                                                                           position,
+                                                                           start_file=alg_str[1])
+                return Move(end_loc=end_location,
+                            piece=possible_piece,
+                            status=notation_const.CAPTURE,
+                            start_loc=start_location)
+
+    # Pawn promotion with capture
+    if len(alg_str) == 6 and alg_str[4] == "=":
+        start_file = ord(alg_str[0]) - 97
+        promote_capture_end_loc = Location.from_string(alg_str[2:4])
+        return Move(end_loc=promote_capture_end_loc,
+                    piece=Pawn(input_color, promote_capture_end_loc),
+                    status=notation_const.CAPTURE_AND_PROMOTE,
+                    promoted_to_piece=_get_piece(alg_str, 5),
+                    start_loc=Location(end_location.shift_back(input_color).rank, start_file))
+
+    raise ValueError("algebraic string {} is invalid in \n{}".format(alg_str, position))
+
+
+def make_legal(move, position):
+    """
+    Converts an incomplete move (initial ``Location`` not specified)
+    and the corresponding position into the a complete move
+    with the most likely starting point specified. If no moves match, ``None``
+    is returned.
+
+    :type: move: Move
+    :type: position: Board
+    :rtype: Move
+    """
+    assert isinstance(move, Move)
+    for legal_move in position.all_possible_moves(move.color):
+
+        if move.status == notation_const.LONG_ALG:
+            if move.end_loc == legal_move.end_loc and \
+                    move.start_loc == legal_move.start_loc:
+                return legal_move
+
+        elif move == legal_move:
+            return legal_move
+
+    raise ValueError("Move {} not legal in \n{}".format(repr(move), position))
+
+
+def short_alg(algebraic_string, input_color, position):
+    """
+    Converts a string written in short algebraic form, the color
+    of the side whose turn it is, and the corresponding position
+    into a complete move that can be played. If no moves match,
+    None is returned.
+
+    Examples: e4, Nf3, exd5, Qxf3, 00, 000, e8=Q
+
+    :type: algebraic_string: str
+    :type: input_color: Color
+    :type: position: Board
+    """
+    return make_legal(incomplete_alg(algebraic_string, input_color, position), position)
+
+
+def long_alg(alg_str, position):
+    """
+    Converts a string written in long algebraic form
+    and the corresponding position into a complete move
+    (initial location specified). Used primarily for
+    UCI, but can be used for other purposes.
+
+    :type: alg_str: str
+    :type: position: Board
+    :rtype: Move
+    """
+    if alg_str is None or len(alg_str) < 4 or len(alg_str) > 6:
+        raise ValueError("Invalid string input {}".format(alg_str))
+
+    end = Location.from_string(alg_str[2:])
+    start = Location.from_string(alg_str[:2])
+    piece = position.piece_at_square(start)
+
+    if len(alg_str) == 4:
+        return make_legal(Move(end_loc=end,
+                               piece=piece,
+                               status=notation_const.LONG_ALG,
+                               start_loc=start), position)
+
+    promoted_to = _get_piece(alg_str, 4)
+    if promoted_to is None or \
+            promoted_to is King or \
+            promoted_to is Pawn:
+        raise Exception("Invalid move input")
+
+    return make_legal(Move(end_loc=end,
+                           piece=piece,
+                           status=notation_const.LONG_ALG,
+                           start_loc=start,
+                           promoted_to_piece=promoted_to), position)
Index: chess_py/game/game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/game/game.py	(date 1547148467000)
+++ chess_py/game/game.py	(date 1547148467000)
@@ -0,0 +1,91 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class that holds state of a game.
+
+Takes two subclasses of Player as defined
+in chess_py.players.player.Player, and calls 
+``generate_move(position)``
+from each of the players and updates the board using 
+each corresponding result.
+
+Start game using play(), which returns the result 
+(1 - white wins, 0 - black wins, 0.5 - draw)
+when the game is finished.
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+import itertools
+
+from ..core.board import Board
+from ..core import color
+from . import game_state
+from ..core.algebraic.converter import make_legal
+
+
+class Game:
+    def __init__(self, player_white, player_black):
+        """
+        Creates new game given the players.
+
+        :type: player_white: Player
+        :type: player_black: Player
+        """
+        self.player_white = player_white
+        self.player_black = player_black
+        self.position = Board.init_default()
+
+    def play(self):
+        """
+        Starts game and returns one of 3 results . 
+        Iterates between methods ``white_move()`` and
+        ``black_move()`` until game ends. Each
+        method calls the respective player's ``generate_move()``
+        method.
+
+        :rtype: int
+        """
+        colors = [lambda: self.white_move(), lambda: self.black_move()]
+        colors = itertools.cycle(colors)
+
+        while True:
+            color_fn = next(colors)
+            if game_state.no_moves(self.position):
+                if self.position.get_king(color.white).in_check(self.position):
+                    return 1
+
+                elif self.position.get_king(color.black).in_check(self.position):
+                    return 0
+
+                else:
+                    return 0.5
+
+            color_fn()
+
+    def white_move(self):
+        """
+        Calls the white player's ``generate_move()``
+        method and updates the board with the move returned.
+        """
+        move = self.player_white.generate_move(self.position)
+        move = make_legal(move, self.position)
+        self.position.update(move)
+
+    def black_move(self):
+        """
+        Calls the black player's ``generate_move()``
+        method and updates the board with the move returned.
+        """
+        move = self.player_black.generate_move(self.position)
+        move = make_legal(move, self.position)
+        self.position.update(move)
+
+    def all_possible_moves(self, input_color):
+        """
+        Finds all possible moves a particular player can
+        play during a game. Calling this method is recommended over
+        calling the ``all_possible_moves(input_color)``
+        from this ``Board`` directly.
+        """
+        return self.position.all_possible_moves(input_color)
Index: chess_py/game/game_state.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/game/game_state.py	(date 1547148472000)
+++ chess_py/game/game_state.py	(date 1547148472000)
@@ -0,0 +1,33 @@
+# -*- coding: utf-8 -*-
+
+"""
+Static methods which check to see if
+game is over, and if a King is checkmated.
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+from ..core import color
+
+
+def no_moves(position):
+    """
+    Finds if the game is over.
+
+    :type: position: Board
+    :rtype: bool
+    """
+    return position.no_moves(color.white) \
+        or position.no_moves(color.black)
+
+
+def is_checkmate(position, input_color):
+    """
+    Finds if particular King is checkmated.
+
+    :type: position: Board
+    :type: input_color: Color
+    :rtype: bool
+    """
+    return position.no_moves(input_color) and \
+        position.get_king(input_color).in_check(position)
Index: chess_py/game/interface.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/game/interface.py	(date 1547112767000)
+++ chess_py/game/interface.py	(date 1547112767000)
@@ -0,0 +1,83 @@
+
+from multiprocessing import Process
+
+from ..core import Board
+
+
+class UCI:
+    def __init__(self, player, engine_name, author):
+        """
+
+        :type: player: Player
+        """
+        self.player = player
+        self.engine = engine_name
+        self.author = author
+        self.position = Board.init_default()
+        self.running = True
+        self.latest_input = ""
+
+    def play(self):
+        self.runInParallel(lambda: self.read(), lambda: self.set_up())
+        self.set_up()
+
+    def set_up(self):
+        self.wait_for("uci")
+
+        self.write("id name " + self.engine)
+        self.write("id author " + self.author)
+
+        self.write("uciok")
+
+        self.wait_for("ucinewgame")
+        self.start_game()
+
+    def start_game(self):
+        if self.latest_input == "isready":
+            self.write("readyok")
+
+        self.wait_for("")
+
+    def wait_for(self, command):
+        """
+        Waits until ``self.latest_input`` is a certain command
+        :type command:
+        """
+        while self.latest_input != command:
+            pass
+
+    def read(self):
+        """
+        Continuously reads from the console and updates
+        ``self.latest_input`` with latest command. Runs
+        as a side process at all times so main process
+        has the most current information form the console
+        accessed through ``self.latest_input``.
+        """
+        while self.running:
+            self.latest_input = self.player.getUCI()
+
+    def write(self, command):
+        """
+        Writes to the console given the command.
+        Called by the main process when it needs to
+        send commands to the console.
+
+        :type: command: str
+        """
+        self.player.setUCI(command)
+
+    def runInParallel(*fns):
+        """
+        Runs multiple processes in parallel.
+
+        :type: fns: def
+        """
+        proc = []
+        for fn in fns:
+            p = Process(target=fn)
+            p.start()
+            proc.append(p)
+        for p in proc:
+            p.join()
+
Index: chess_py/game/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/game/__init__.py	(date 1547112767000)
+++ chess_py/game/__init__.py	(date 1547112767000)
@@ -0,0 +1,4 @@
+from .game import Game
+from . import game_state
+
+__all__ = ['Game', 'game_state']
Index: chess_py/pieces/pawn.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/pieces/pawn.py	(date 1547148440000)
+++ chess_py/pieces/pawn.py	(date 1547148440000)
@@ -0,0 +1,235 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class stores Pawn on the board
+
+| rank
+| 7 8 ║♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜
+| 6 7 ║♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
+| 5 6 ║… … … … … … … …
+| 4 5 ║… … … … … … … …
+| 3 4 ║… … … … … … … …
+| 2 3 ║… … … … … … … …
+| 1 2 ║♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
+| 0 1 ║♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖
+| ----╚═══════════════
+| ——---a b c d e f g h
+| -----0 1 2 3 4 5 6 7
+| ------file
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+import itertools
+
+from .bishop import Bishop
+from .piece import Piece
+from .queen import Queen
+from .rook import Rook
+from .knight import Knight
+from ..core import color
+from ..core.algebraic import notation_const
+from ..core.algebraic.move import Move
+
+
+class Pawn(Piece):
+    def __init__(self, input_color, location):
+        """
+        Initializes a Pawn that is capable of moving
+
+        :type: input_color: Color
+        :type: location: Location
+        """
+        self.just_moved_two_steps = False
+        super(Pawn, self).__init__(input_color, location)
+
+    def _symbols(self):
+        return {color.white: "♟", color.black: "♙"}
+
+    def __str__(self):
+        return "P"
+
+    def on_home_row(self, location=None):
+        """
+        Finds out if the piece is on the home row.
+
+        :return: bool for whether piece is on home row or not
+        """
+        location = location or self.location
+        return (self.color == color.white and location.rank == 1) or \
+               (self.color == color.black and location.rank == 6)
+
+    def would_move_be_promotion(self, location=None):
+        """
+        Finds if move from current get_location would result in promotion
+
+        :type: location: Location
+        :rtype: bool
+        """
+        location = location or self.location
+        return (location.rank == 1 and self.color == color.black) or \
+                (location.rank == 6 and self.color == color.white)
+
+    def square_in_front(self, location=None):
+        """
+        Finds square directly in front of Pawn
+
+        :type: location: Location
+        :rtype: Location
+        """
+        location = location or self.location
+        return location.shift_up() if self.color == color.white else location.shift_down()
+
+    def two_squares_in_front(self, location):
+        """
+        Finds square two squares in front of Pawn
+
+        :type: location: Location
+        :rtype: get_location
+        """
+        return self.square_in_front(self.square_in_front(location))
+
+    def create_promotion_moves(self, status, location=None):
+        location = location or self.square_in_front()
+        def create_each_move(piece):
+            return Move(end_loc=location,
+                        piece=self,
+                        status=status,
+                        start_loc=self.location,
+                        promoted_to_piece=piece)
+
+        yield create_each_move(Queen)
+        yield create_each_move(Rook)
+        yield create_each_move(Bishop)
+        yield create_each_move(Knight)
+
+    def forward_moves(self, position):
+        """
+        Finds possible moves one step and two steps in front
+        of Pawn.
+
+        :type: position: Board
+        :rtype: list
+        """
+        if position.is_square_empty(self.square_in_front(self.location)):
+            """
+            If square in front is empty add the move
+            """
+            if self.would_move_be_promotion():
+                for move in self.create_promotion_moves(notation_const.PROMOTE):
+                    yield move
+            else:
+                yield self.create_move(end_loc=self.square_in_front(self.location),
+                                       status=notation_const.MOVEMENT)
+
+            if self.on_home_row() and \
+                    position.is_square_empty(self.two_squares_in_front(self.location)):
+                """
+                If pawn is on home row and two squares in front of the pawn is empty
+                add the move
+                """
+                yield self.create_move(
+                    end_loc=self.square_in_front(self.square_in_front(self.location)),
+                    status=notation_const.MOVEMENT
+                )
+
+    def _one_diagonal_capture_square(self, capture_square, position):
+        """
+        Adds specified diagonal as a capture move if it is one
+        """
+        if self.contains_opposite_color_piece(capture_square, position):
+
+            if self.would_move_be_promotion():
+                for move in self.create_promotion_moves(status=notation_const.CAPTURE_AND_PROMOTE,
+                                                        location=capture_square):
+                    yield move
+
+            else:
+                yield self.create_move(end_loc=capture_square,
+                                       status=notation_const.CAPTURE)
+
+    def capture_moves(self, position):
+        """
+        Finds out all possible capture moves
+
+        :rtype: list
+        """
+        try:
+            right_diagonal = self.square_in_front(self.location.shift_right())
+            for move in self._one_diagonal_capture_square(right_diagonal, position):
+                yield move
+        except IndexError:
+            pass
+
+        try:
+            left_diagonal = self.square_in_front(self.location.shift_left())
+            for move in self._one_diagonal_capture_square(left_diagonal, position):
+                yield move
+        except IndexError:
+            pass
+
+    def on_en_passant_valid_location(self):
+        """
+        Finds out if pawn is on enemy center rank.
+
+        :rtype: bool
+        """
+        return (self.color == color.white and self.location.rank == 4) or \
+               (self.color == color.black and self.location.rank == 3)
+
+    def _is_en_passant_valid(self, opponent_pawn_location, position):
+        """
+        Finds if their opponent's pawn is next to this pawn
+
+        :rtype: bool
+        """
+        try:
+            pawn = position.piece_at_square(opponent_pawn_location)
+            return pawn is not None and \
+                isinstance(pawn, Pawn) and \
+                pawn.color != self.color and \
+                position.piece_at_square(opponent_pawn_location).just_moved_two_steps
+        except IndexError:
+            return False
+
+    def add_one_en_passant_move(self, direction, position):
+        """
+        Yields en_passant moves in given direction if it is legal.
+
+        :type: direction: function
+        :type: position: Board
+        :rtype: gen
+        """
+        try:
+            if self._is_en_passant_valid(direction(self.location), position):
+                yield self.create_move(
+                    end_loc=self.square_in_front(direction(self.location)),
+                    status=notation_const.EN_PASSANT
+                )
+        except IndexError:
+            pass
+
+    def en_passant_moves(self, position):
+        """
+        Finds possible en passant moves.
+
+        :rtype: list
+        """
+
+        # if pawn is not on a valid en passant get_location then return None
+        if self.on_en_passant_valid_location():
+            for move in itertools.chain(self.add_one_en_passant_move(lambda x: x.shift_right(), position),
+                                        self.add_one_en_passant_move(lambda x: x.shift_left(), position)):
+                yield move
+
+    def possible_moves(self, position):
+        """
+        Finds out the locations of possible moves given board.Board position.
+        :pre get_location is on board and piece at specified get_location on position
+
+        :type: position: Board
+        :rtype: list
+        """
+        for move in itertools.chain(self.forward_moves(position),
+                                    self.capture_moves(position),
+                                    self.en_passant_moves(position)):
+            yield move
Index: chess_py/pieces/rook.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/pieces/rook.py	(date 1547148459000)
+++ chess_py/pieces/rook.py	(date 1547148459000)
@@ -0,0 +1,80 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class stores Rook on the board
+
+| rank
+| 7 8 ║♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜
+| 6 7 ║♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
+| 5 6 ║… … … … … … … …
+| 4 5 ║… … … … … … … …
+| 3 4 ║… … … … … … … …
+| 2 3 ║… … … … … … … …
+| 1 2 ║♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
+| 0 1 ║♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖
+| ----╚═══════════════
+| ——---a b c d e f g h
+| -----0 1 2 3 4 5 6 7
+| ------file
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+import itertools
+
+from .piece import Piece
+from ..core.algebraic import notation_const
+from ..core import color
+
+
+class Rook(Piece):
+    def __init__(self, input_color, location):
+        """
+        Initializes a rook that is capable of being compared to another rook,
+        and returning a list of possible moves.
+
+        :type: input_color: Color
+        :type: location: Location
+        """
+        super(Rook, self).__init__(input_color, location)
+        self.has_moved = False
+
+    def _symbols(self):
+        return {color.white: "♜", color.black: "♖"}
+
+    def __str__(self):
+        return "R"
+
+    def moves_in_direction(self, direction, position):
+        """
+        Finds moves in a given direction
+
+        :type: direction: lambda
+        :type: position: Board
+        :rtype: list
+        """
+        current_square = self.location
+
+        while True:
+            try:
+                current_square = direction(current_square)
+            except IndexError:
+                return
+
+            if self.contains_opposite_color_piece(current_square, position):
+                yield self.create_move(current_square, notation_const.CAPTURE)
+
+            if not position.is_square_empty(current_square):
+                return
+
+            yield self.create_move(current_square, notation_const.MOVEMENT)
+
+    def possible_moves(self, position):
+        """
+        Returns all possible rook moves.
+
+        :type: position: Board
+        :rtype: list
+        """
+        for move in itertools.chain(*[self.moves_in_direction(fn, position) for fn in self.cross_fn]):
+            yield move
Index: chess_py/pieces/queen.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/pieces/queen.py	(date 1547148454000)
+++ chess_py/pieces/queen.py	(date 1547148454000)
@@ -0,0 +1,44 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class stores Queen on the board
+
+| rank
+| 7 8 ║♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜
+| 6 7 ║♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
+| 5 6 ║… … … … … … … …
+| 4 5 ║… … … … … … … …
+| 3 4 ║… … … … … … … …
+| 2 3 ║… … … … … … … …
+| 1 2 ║♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
+| 0 1 ║♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖
+| ----╚═══════════════
+| ——---a b c d e f g h
+| -----0 1 2 3 4 5 6 7
+| ------file
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+import itertools
+
+from .piece import Piece
+from .rook import Rook
+from .bishop import Bishop
+from ..core import color
+
+
+class Queen(Bishop, Piece):
+    def __init__(self, input_color, location):
+        Piece.__init__(self, input_color, location)
+
+    def _symbols(self):
+        return {color.white: "♛", color.black: "♕"}
+
+    def __str__(self):
+        return "Q"
+
+    def possible_moves(self, position):
+        for move in itertools.chain(Rook.possible_moves(self, position),
+                                    Bishop.possible_moves(self, position)):
+            yield move
Index: chess_py/pieces/piece.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/pieces/piece.py	(date 1547148444000)
+++ chess_py/pieces/piece.py	(date 1547148444000)
@@ -0,0 +1,97 @@
+# -*- coding: utf-8 -*-
+
+"""
+Parent class for all pieces
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+from abc import ABCMeta, abstractmethod
+
+from ..core.algebraic.location import Location
+from ..core import color
+from ..core.color import Color
+
+
+class Piece:
+    __metaclass__ = ABCMeta
+
+    @abstractmethod
+    def __init__(self, input_color, location):
+        """
+        Initializes a piece that is capable of moving
+
+        :type: input_color: Color
+        :type: location: Location
+        :type: white_symbol: str
+        :type: black_symbol: str
+        """
+        assert isinstance(input_color, Color)
+        assert isinstance(location, Location)
+
+        self.color = input_color
+        self.location = location
+
+        self.cross_fn = [lambda x: x.shift_up(), lambda x: x.shift_right(),
+                         lambda x: x.shift_down(), lambda x: x.shift_left()]
+
+        self.diag_fn = [lambda x: x.shift_up_right(), lambda x: x.shift_up_left(),
+                        lambda x: x.shift_down_right(), lambda x: x.shift_down_left()]
+
+    def __key(self):
+        return self.color, self.location
+
+    def __hash__(self):
+        return hash(str(self))
+
+    def __eq__(self, other):
+        """
+        Finds out if piece is the same type and color as self
+        :type: other: Piece
+        """
+        return type(other) is type(self) and other.color == self.color
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def __repr__(self):
+        return "{}({}, {})".format(self.__class__, self.color, self.location)
+
+    @abstractmethod
+    def __str__(self):
+        pass
+
+    @abstractmethod
+    def _symbols(self):
+        pass
+
+    @abstractmethod
+    def possible_moves(self, position):
+        pass
+
+    def __copy__(self):
+        return self.__class__(self.color, self.location)
+
+    @property
+    def symbol(self):
+        return self._symbols()[self.color]
+
+    def contains_opposite_color_piece(self, square, position):
+        """
+        Finds if square on the board is occupied by a ``Piece``
+        belonging to the opponent.
+
+        :type: square: Location
+        :type: position: Board
+        :rtype: bool
+        """
+        return not position.is_square_empty(square) and \
+            position.piece_at_square(square).color != self.color
+
+    def create_move(self, end_loc, status):
+        # TODO: fix circular imports
+        from chess_py import Move
+        return Move(end_loc=end_loc,
+                    piece=self,
+                    status=status,
+                    start_loc=self.location)
Index: chess_py/pieces/king.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/pieces/king.py	(date 1547148433000)
+++ chess_py/pieces/king.py	(date 1547148433000)
@@ -0,0 +1,199 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class stores King on the board
+
+| rank
+| 7 8 ║♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜
+| 6 7 ║♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
+| 5 6 ║… … … … … … … …
+| 4 5 ║… … … … … … … …
+| 3 4 ║… … … … … … … …
+| 2 3 ║… … … … … … … …
+| 1 2 ║♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
+| 0 1 ║♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖
+| ----╚═══════════════
+| ——---a b c d e f g h
+| -----0 1 2 3 4 5 6 7
+| ------file
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+import itertools
+from copy import copy as cp
+
+from .piece import Piece
+from .rook import Rook
+from ..core.algebraic import notation_const
+from ..core import color
+from ..core.algebraic.location import Location
+
+
+class King(Piece):
+    def __init__(self, input_color, location):
+        """
+        Creates a King.
+
+        :type: input_color: Color
+        :type: location: Location
+        """
+        super(King, self).__init__(input_color, location)
+        self.has_moved = False
+        self.cardinal_directions = self.cross_fn + self.diag_fn
+
+    def _symbols(self):
+        return {color.white: "♚", color.black: "♔"}
+
+    def __str__(self):
+        return "K"
+
+    def in_check_as_result(self, pos, move):
+        """
+        Finds if playing my move would make both kings meet.
+
+        :type: pos: Board
+        :type: move: Move
+        :rtype: bool
+        """
+        test = cp(pos)
+        test.update(move)
+        test_king = test.get_king(move.color)
+
+        return self.loc_adjacent_to_opponent_king(test_king.location, test)
+
+    def loc_adjacent_to_opponent_king(self, location, position):
+        """
+        Finds if 2 kings are touching given the position of one of the kings.
+
+        :type: location: Location
+        :type: position: Board
+        :rtype: bool
+        """
+        for fn in self.cardinal_directions:
+            try:
+                if isinstance(position.piece_at_square(fn(location)), King) and \
+                        position.piece_at_square(fn(location)).color != self.color:
+                    return True
+
+            except IndexError:
+                pass
+
+        return False
+
+    def add(self, func, position):
+        """
+        Adds all 8 cardinal directions as moves for the King if legal.
+
+        :type: function: function
+        :type: position: Board
+        :rtype: gen
+        """
+        try:
+            if self.loc_adjacent_to_opponent_king(func(self.location), position):
+                return
+        except IndexError:
+            return
+
+        if position.is_square_empty(func(self.location)):
+            yield self.create_move(func(self.location), notation_const.MOVEMENT)
+
+        elif position.piece_at_square(func(self.location)).color != self.color:
+            yield self.create_move(func(self.location), notation_const.CAPTURE)
+
+    def _rook_legal_for_castle(self, rook):
+        """
+        Decides if given rook exists, is of this color, and has not moved so it
+        is eligible to castle.
+
+        :type: rook: Rook
+        :rtype: bool
+        """
+        return rook is not None and \
+            type(rook) is Rook and \
+            rook.color == self.color and \
+            not rook.has_moved
+
+    def _empty_not_in_check(self, position, direction):
+        """
+        Checks if set of squares in between ``King`` and ``Rook`` are empty and safe
+        for the king to castle.
+
+        :type: position: Position
+        :type: direction: function
+        :type: times: int
+        :rtype: bool
+        """
+        def valid_square(square):
+            return position.is_square_empty(square) and \
+                   not self.in_check(position, square)
+
+        return valid_square(direction(self.location, 1)) and \
+            valid_square(direction(self.location, 2))
+
+    def add_castle(self, position):
+        """
+        Adds kingside and queenside castling moves if legal
+
+        :type: position: Board
+        """
+        if self.has_moved or self.in_check(position):
+            return
+
+        if self.color == color.white:
+            rook_rank = 0
+        else:
+            rook_rank = 7
+
+        castle_type = {
+            notation_const.KING_SIDE_CASTLE: {
+                "rook_file": 7,
+                "direction": lambda king_square, times: king_square.shift_right(times)
+            },
+            notation_const.QUEEN_SIDE_CASTLE: {
+                "rook_file": 0,
+                "direction": lambda king_square, times: king_square.shift_left(times)
+            }
+        }
+        for castle_key in castle_type:
+            castle_dict = castle_type[castle_key]
+            castle_rook = position.piece_at_square(Location(rook_rank, castle_dict["rook_file"]))
+            if self._rook_legal_for_castle(castle_rook) and \
+                    self._empty_not_in_check(position, castle_dict["direction"]):
+                yield self.create_move(castle_dict["direction"](self.location, 2), castle_key)
+
+    def possible_moves(self, position):
+        """
+        Generates list of possible moves
+
+        :type: position: Board
+        :rtype: list
+        """
+        # Chain used to combine multiple generators
+        for move in itertools.chain(*[self.add(fn, position) for fn in self.cardinal_directions]):
+            yield move
+
+        for move in self.add_castle(position):
+            yield move
+
+    def in_check(self, position, location=None):
+        """
+        Finds if the king is in check or if both kings are touching.
+
+        :type: position: Board
+        :return: bool
+        """
+        location = location or self.location
+        for piece in position:
+
+            if piece is not None and piece.color != self.color:
+                if not isinstance(piece, King):
+                    for move in piece.possible_moves(position):
+
+                        if move.end_loc == location:
+                            return True
+                else:
+                    if self.loc_adjacent_to_opponent_king(piece.location, position):
+                        return True
+
+        return False
Index: chess_py/pieces/piece_const.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/pieces/piece_const.py	(date 1547148450000)
+++ chess_py/pieces/piece_const.py	(date 1547148450000)
@@ -0,0 +1,74 @@
+# -*- coding: utf-8 -*-
+
+"""
+Constants for piece values in the game
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+from .bishop import Bishop
+from .pawn import Pawn
+from .queen import Queen
+from .rook import Rook
+from .knight import Knight
+from .king import King
+
+
+class PieceValues:
+    def __init__(self):
+        self.PAWN_VALUE = 1
+        self.KNIGHT_VALUE = 3
+        self.BISHOP_VALUE = 3.5
+        self.ROOK_VALUE = 5
+        self.QUEEN_VALUE = 9
+        self.KING_VALUE = 999
+
+    @classmethod
+    def init_manual(cls, pawn_value, knight_value, bishop_value, rook_value, queen_value, king_value):
+        """
+        Manual init method for external piece values
+
+        :type: PAWN_VALUE: int
+        :type: KNIGHT_VALUE: int
+        :type: BISHOP_VALUE: int
+        :type: ROOK_VALUE: int
+        :type: QUEEN_VALUE: int
+        """
+        piece_values = cls()
+        piece_values.PAWN_VALUE = pawn_value
+        piece_values.KNIGHT_VALUE = knight_value
+        piece_values.BISHOP_VALUE = bishop_value
+        piece_values.ROOK_VALUE = rook_value
+        piece_values.QUEEN_VALUE = queen_value
+        piece_values.KING_VALUE = king_value
+        return piece_values
+
+    def val(self, piece, ref_color):
+        """
+        Finds value of ``Piece``
+
+        :type: piece: Piece
+        :type: ref_color: Color
+        :rtype: int
+        """
+        if piece is None:
+            return 0
+
+        if ref_color == piece.color:
+            const = 1
+        else:
+            const = -1
+
+        if isinstance(piece, Pawn):
+            return self.PAWN_VALUE * const
+        elif isinstance(piece, Queen):
+            return self.QUEEN_VALUE * const
+        elif isinstance(piece, Bishop):
+            return self.BISHOP_VALUE * const
+        elif isinstance(piece, Rook):
+            return self.ROOK_VALUE * const
+        elif isinstance(piece, Knight):
+            return self.KNIGHT_VALUE * const
+        elif isinstance(piece, King):
+            return self.KING_VALUE * const
+        return 0
Index: chess_py/pieces/knight.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/pieces/knight.py	(date 1547148436000)
+++ chess_py/pieces/knight.py	(date 1547148436000)
@@ -0,0 +1,82 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class stores Knight on the board
+
+| rank
+| 7 8 ║♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜
+| 6 7 ║♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
+| 5 6 ║… … … … … … … …
+| 4 5 ║… … … … … … … …
+| 3 4 ║… … … … … … … …
+| 2 3 ║… … … … … … … …
+| 1 2 ║♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
+| 0 1 ║♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖
+| ----╚═══════════════
+| ——---a b c d e f g h
+| -----0 1 2 3 4 5 6 7
+| ------file
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+from ..core.algebraic import notation_const
+from ..pieces.piece import Piece
+from ..core.algebraic.move import Move
+from ..core import color
+
+
+class Knight(Piece):
+    def __init__(self, input_color, location):
+        """
+        Initializes Knight
+        :type: input_color: Color
+        :type: location Location
+        """
+        super(Knight, self).__init__(input_color, location)
+
+    def _symbols(self):
+        return {color.white: "♞", color.black: "♘"}
+
+    def __str__(self):
+        return "N"
+
+    @staticmethod
+    def _rotate_direction_ninety_degrees(direction):
+        if direction == 3:
+            return 0, 2
+        right_angles = [direction - 1, direction + 1]
+        for index, angle in enumerate(right_angles):
+            if angle == -1:
+                right_angles[index] = 3
+            elif angle == 4:
+                right_angles[index] = 0
+
+        return right_angles
+
+    def possible_moves(self, position):
+        """
+        Finds all possible knight moves
+        :type: position Board
+        :rtype: list
+        """
+        for direction in [0, 1, 2, 3]:
+            angles = self._rotate_direction_ninety_degrees(direction)
+            for angle in angles:
+                try:
+                    end_loc = self.location.shift(angle).shift(direction).shift(direction)
+                    if position.is_square_empty(end_loc):
+                        status = notation_const.MOVEMENT
+                    elif not position.piece_at_square(end_loc).color == self.color:
+                        status = notation_const.CAPTURE
+                    else:
+                        continue
+
+                    yield Move(end_loc=end_loc,
+                               piece=self,
+                               status=status,
+                               start_loc=self.location)
+
+                except IndexError:
+                    pass
+
Index: chess_py/pieces/bishop.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/pieces/bishop.py	(date 1547148422000)
+++ chess_py/pieces/bishop.py	(date 1547148422000)
@@ -0,0 +1,54 @@
+# -*- coding: utf-8 -*-
+
+"""
+Class stores Bishop on the board
+
+| rank
+| 7 8 ║♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜
+| 6 7 ║♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
+| 5 6 ║… … … … … … … …
+| 4 5 ║… … … … … … … …
+| 3 4 ║… … … … … … … …
+| 2 3 ║… … … … … … … …
+| 1 2 ║♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
+| 0 1 ║♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖
+| ----╚═══════════════
+| ——---a b c d e f g h
+| -----0 1 2 3 4 5 6 7
+| ------file
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+import itertools
+
+from .piece import Piece
+from .rook import Rook
+from ..core import color
+
+
+class Bishop(Rook, Piece):
+    def __init__(self, input_color, location):
+        """
+        Creates Bishop object that can be compared to and return possible moves
+
+        :type: input_color: Color
+        """
+        Piece.__init__(self, input_color, location)
+
+    def _symbols(self):
+        return {color.white: "♝", color.black: "♗"}
+
+    def __str__(self):
+        return "B"
+
+    def possible_moves(self, position):
+        """
+        Returns all possible bishop moves.
+
+        :type: position: Board
+        :rtype: list
+        """
+
+        for move in itertools.chain(*[self.moves_in_direction(fn, position) for fn in self.diag_fn]):
+            yield move
Index: chess_py/pieces/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/pieces/__init__.py	(date 1547112767000)
+++ chess_py/pieces/__init__.py	(date 1547112767000)
@@ -0,0 +1,10 @@
+from .bishop import Bishop
+from .king import King
+from .knight import Knight
+from .pawn import Pawn
+from .piece import Piece
+from .queen import Queen
+from .rook import Rook
+from .piece_const import PieceValues
+
+__all__ = ['Bishop', 'King', 'Knight', 'Pawn', 'Piece', 'piece_const', 'Queen', 'Rook']
Index: chess_py/players/human.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/players/human.py	(date 1547148536000)
+++ chess_py/players/human.py	(date 1547148536000)
@@ -0,0 +1,43 @@
+# -*- coding: utf-8 -*-
+
+"""
+Included class for human interaction via console.
+Prints position and takes move written in algebraic notation as string input
+
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+from chess_py.core.algebraic import converter
+from chess_py.players.player import Player
+
+try:
+    input = raw_input
+except NameError:
+    pass
+
+
+class Human(Player):
+    def __init__(self, input_color):
+        """
+        Creates interface for human player.
+
+        :type: input_color: Color
+        """
+        super(Human, self).__init__(input_color)
+
+    def generate_move(self, position):
+        """
+        Returns valid and legal move given position
+
+        :type: position: Board
+        :rtype: Move
+        """
+        while True:
+            print(position)
+            raw = input(str(self.color) + "\'s move \n")
+            move = converter.short_alg(raw, self.color, position)
+
+            if move is None:
+                continue
+
+            return move
Index: chess_py/players/player.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/players/player.py	(date 1547148542000)
+++ chess_py/players/player.py	(date 1547148542000)
@@ -0,0 +1,56 @@
+# -*- coding: utf-8 -*-
+
+"""
+Parent class of chess engines built on chess_py. This class must be inherited
+and abstract method ``generate_move(self, position) must be implemented.``.
+| Copyright © 2018 Maxim Yurchenko. All rights reserved.
+"""
+
+from abc import ABCMeta, abstractmethod
+from pip._vendor.distlib.compat import raw_input
+import sys
+
+
+class Player:
+    __metaclass__ = ABCMeta
+
+    def __init__(self, input_color):
+        """
+        Creates interface for base player.
+
+        :type: input_color: Color
+        """
+        self.color = input_color
+
+    @abstractmethod
+    def generate_move(self, position):
+        """
+        Must be implemented by classes that extend ``Player``.
+        Must return object of type ``Move``.
+
+        :type: position: Board
+        :rtype: Move
+        """
+        pass
+
+    @staticmethod
+    def getUCI():
+        """
+        Internal method used by ``Interface``
+        to read UCI commands from external GUI.
+
+        :rtype: str
+        """
+        return sys.stdin.read()
+
+    @staticmethod
+    def setUCI(command):
+        """
+        Internal method used by ``Interface``
+        to write UCI commands to the console so they
+        can be read by external GUI.
+
+        :type: command: str
+        """
+        sys.stdout.write(command)
+
Index: chess_py/players/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- chess_py/players/__init__.py	(date 1547112767000)
+++ chess_py/players/__init__.py	(date 1547112767000)
@@ -0,0 +1,4 @@
+from chess_py.players.human import Human
+from chess_py.players.player import Player
+
+__all__ = ['Human', 'Player']
Index: docs/conf.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/conf.py	(date 1547112767000)
+++ docs/conf.py	(date 1547112767000)
@@ -0,0 +1,360 @@
+# -*- coding: utf-8 -*-
+#
+# chess_py documentation build configuration file, created by
+# sphinx-quickstart on Sat Sep 17 16:32:26 2016.
+#
+# This file is execfile()d with the current directory set to its
+# containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+import sys
+import os
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+sys.path.insert(0, os.path.abspath("../"))
+
+# -- General configuration ------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+#needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
+# ones.
+extensions = [
+    'sphinx.ext.autodoc',
+    'sphinx.ext.todo',
+    'sphinx.ext.viewcode',
+]
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# The suffix(es) of source filenames.
+# You can specify multiple suffix as a list of string:
+# source_suffix = ['.rst', '.md']
+source_suffix = '.rst'
+
+# The encoding of source files.
+#source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = u'chess_py'
+copyright = u'2016, Aubhro Sengupta'
+author = u'Aubhro Sengupta'
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+#
+# The short X.Y version.
+version = u''
+# The full version, including alpha/beta/rc tags.
+release = u''
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#
+# This is also used if you do content translation via gettext catalogs.
+# Usually you set "language" from the command line for these cases.
+language = 'en'
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+#today = ''
+# Else, today_fmt is used as the format for a strftime call.
+#today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+# This patterns also effect to html_static_path and html_extra_path
+exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
+
+# The reST default role (used for this markup: `text`) to use for all
+# documents.
+#default_role = None
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+#add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+#add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+#show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+# A list of ignored prefixes for module index sorting.
+#modindex_common_prefix = []
+
+# If true, keep warnings as "system message" paragraphs in the built documents.
+#keep_warnings = False
+
+# If true, `todo` and `todoList` produce output, else they produce nothing.
+todo_include_todos = True
+
+
+# -- Options for HTML output ----------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+html_theme = 'classic'
+
+# Theme options are theme-specific and customize the look and feel of a theme
+# further.  For a list of options available for each theme, see the
+# documentation.
+#html_theme_options = {}
+
+# Add any paths that contain custom themes here, relative to this directory.
+#html_theme_path = []
+
+# The name for this set of Sphinx documents.
+# "<project> v<release> documentation" by default.
+#html_title = u'chess_py v'
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+#html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+#html_logo = None
+
+# The name of an image file (relative to this directory) to use as a favicon of
+# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+#html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
+
+# Add any extra paths that contain custom files (such as robots.txt or
+# .htaccess) here, relative to this directory. These files are copied
+# directly to the root of the documentation.
+#html_extra_path = []
+
+# If not None, a 'Last updated on:' timestamp is inserted at every page
+# bottom, using the given strftime format.
+# The empty string is equivalent to '%b %d, %Y'.
+#html_last_updated_fmt = None
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+#html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+#html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+#html_additional_pages = {}
+
+# If false, no module index is generated.
+#html_domain_indices = True
+
+# If false, no index is generated.
+#html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+#html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+#html_show_sourcelink = True
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+#html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+#html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+#html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+#html_file_suffix = None
+
+# Language to be used for generating the HTML full-text search index.
+# Sphinx supports the following languages:
+#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'
+#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr', 'zh'
+#html_search_language = 'en'
+
+# A dictionary with options for the search language support, empty by default.
+# 'ja' uses this config value.
+# 'zh' user can custom change `jieba` dictionary path.
+#html_search_options = {'type': 'default'}
+
+# The name of a javascript file (relative to the configuration directory) that
+# implements a search results scorer. If empty, the default will be used.
+#html_search_scorer = 'scorer.js'
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'chess_pydoc'
+
+# -- Options for LaTeX output ---------------------------------------------
+
+latex_elements = {
+# The paper size ('letterpaper' or 'a4paper').
+#'papersize': 'letterpaper',
+
+# The font size ('10pt', '11pt' or '12pt').
+#'pointsize': '10pt',
+
+# Additional stuff for the LaTeX preamble.
+#'preamble': '',
+
+# Latex figure (float) alignment
+#'figure_align': 'htbp',
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title,
+#  author, documentclass [howto, manual, or own class]).
+latex_documents = [
+    (master_doc, 'chess_py.tex', u'chess\\_py Documentation',
+     u'Author', 'manual'),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+#latex_logo = None
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+#latex_use_parts = False
+
+# If true, show page references after internal links.
+#latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+#latex_show_urls = False
+
+# Documents to append as an appendix to all manuals.
+#latex_appendices = []
+
+# If false, no module index is generated.
+#latex_domain_indices = True
+
+
+# -- Options for manual page output ---------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    (master_doc, 'chess_py', u'chess_py Documentation',
+     [author], 1)
+]
+
+# If true, show URL addresses after external links.
+#man_show_urls = False
+
+
+# -- Options for Texinfo output -------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+    (master_doc, 'chess_py', u'chess_py Documentation',
+     author, 'chess_py', 'One line description of project.',
+     'Miscellaneous'),
+]
+
+# Documents to append as an appendix to all manuals.
+#texinfo_appendices = []
+
+# If false, no module index is generated.
+#texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+#texinfo_show_urls = 'footnote'
+
+# If true, do not generate a @detailmenu in the "Top" node's menu.
+#texinfo_no_detailmenu = False
+
+
+# -- Options for Epub output ----------------------------------------------
+
+# Bibliographic Dublin Core info.
+epub_title = project
+epub_author = author
+epub_publisher = author
+epub_copyright = copyright
+
+# The basename for the epub file. It defaults to the project name.
+#epub_basename = project
+
+# The HTML theme for the epub output. Since the default themes are not
+# optimized for small screen space, using the same theme for HTML and epub
+# output is usually not wise. This defaults to 'epub', a theme designed to save
+# visual space.
+#epub_theme = 'epub'
+
+# The language of the text. It defaults to the language option
+# or 'en' if the language is not set.
+#epub_language = ''
+
+# The scheme of the identifier. Typical schemes are ISBN or URL.
+#epub_scheme = ''
+
+# The unique identifier of the text. This can be a ISBN number
+# or the project homepage.
+#epub_identifier = ''
+
+# A unique identification for the text.
+#epub_uid = ''
+
+# A tuple containing the cover image and cover page html template filenames.
+#epub_cover = ()
+
+# A sequence of (type, uri, title) tuples for the guide element of content.opf.
+#epub_guide = ()
+
+# HTML files that should be inserted before the pages created by sphinx.
+# The format is a list of tuples containing the path and title.
+#epub_pre_files = []
+
+# HTML files that should be inserted after the pages created by sphinx.
+# The format is a list of tuples containing the path and title.
+#epub_post_files = []
+
+# A list of files that should not be packed into the epub file.
+epub_exclude_files = ['search.html']
+
+# The depth of the table of contents in toc.ncx.
+#epub_tocdepth = 3
+
+# Allow duplicate toc entries.
+#epub_tocdup = True
+
+# Choose between 'default' and 'includehidden'.
+#epub_tocscope = 'default'
+
+# Fix unsupported image types using the Pillow.
+#epub_fix_images = False
+
+# Scale large images.
+#epub_max_image_width = 0
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+#epub_show_urls = 'inline'
+
+# If false, no index is generated.
+#epub_use_index = True
Index: docs/chess_py.rst
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/chess_py.rst	(date 1547112767000)
+++ docs/chess_py.rst	(date 1547112767000)
@@ -0,0 +1,9 @@
+chess_py package
+================
+
+.. toctree::
+
+    chess_py.core
+    chess_py.game
+    chess_py.pieces
+    chess_py.players
Index: docs/Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/Makefile	(date 1547112767000)
+++ docs/Makefile	(date 1547112767000)
@@ -0,0 +1,230 @@
+# Makefile for Sphinx documentation
+#
+
+# You can set these variables from the command line.
+SPHINXOPTS    =
+SPHINXBUILD   = sphinx-build
+PAPER         =
+BUILDDIR      = ../gh-pages/html
+
+# User-friendly check for sphinx-build
+ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $$?), 1)
+	$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don\'t have Sphinx installed, grab it from http://sphinx-doc.org/)
+endif
+
+# Internal variables.
+PAPEROPT_a4     = -D latex_paper_size=a4
+PAPEROPT_letter = -D latex_paper_size=letter
+ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+# the i18n builder cannot share the environment and doctrees with the others
+I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+
+.PHONY: help
+help:
+	@echo "Please use \`make <target>' where <target> is one of"
+	@echo "  html       to make standalone HTML files"
+	@echo "  dirhtml    to make HTML files named index.html in directories"
+	@echo "  singlehtml to make a single large HTML file"
+	@echo "  pickle     to make pickle files"
+	@echo "  json       to make JSON files"
+	@echo "  htmlhelp   to make HTML files and a HTML help project"
+	@echo "  qthelp     to make HTML files and a qthelp project"
+	@echo "  applehelp  to make an Apple Help Book"
+	@echo "  devhelp    to make HTML files and a Devhelp project"
+	@echo "  epub       to make an epub"
+	@echo "  epub3      to make an epub3"
+	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
+	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
+	@echo "  latexpdfja to make LaTeX files and run them through platex/dvipdfmx"
+	@echo "  text       to make text files"
+	@echo "  man        to make manual pages"
+	@echo "  texinfo    to make Texinfo files"
+	@echo "  info       to make Texinfo files and run them through makeinfo"
+	@echo "  gettext    to make PO message catalogs"
+	@echo "  changes    to make an overview of all changed/added/deprecated items"
+	@echo "  xml        to make Docutils-native XML files"
+	@echo "  pseudoxml  to make pseudoxml-XML files for display purposes"
+	@echo "  linkcheck  to check all external links for integrity"
+	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
+	@echo "  coverage   to run coverage check of the documentation (if enabled)"
+	@echo "  dummy      to check syntax errors of document sources"
+
+.PHONY: clean
+clean:
+	rm -rf $(BUILDDIR)/*
+
+.PHONY: html
+html:
+	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
+
+.PHONY: dirhtml
+dirhtml:
+	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
+
+.PHONY: singlehtml
+singlehtml:
+	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
+	@echo
+	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."
+
+.PHONY: pickle
+pickle:
+	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
+	@echo
+	@echo "Build finished; now you can process the pickle files."
+
+.PHONY: json
+json:
+	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
+	@echo
+	@echo "Build finished; now you can process the JSON files."
+
+.PHONY: htmlhelp
+htmlhelp:
+	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
+	@echo
+	@echo "Build finished; now you can run HTML Help Workshop with the" \
+	      ".hhp project file in $(BUILDDIR)/htmlhelp."
+
+.PHONY: qthelp
+qthelp:
+	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
+	@echo
+	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
+	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
+	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/chess_py.qhcp"
+	@echo "To view the help file:"
+	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/chess_py.qhc"
+
+.PHONY: applehelp
+applehelp:
+	$(SPHINXBUILD) -b applehelp $(ALLSPHINXOPTS) $(BUILDDIR)/applehelp
+	@echo
+	@echo "Build finished. The help book is in $(BUILDDIR)/applehelp."
+	@echo "N.B. You won't be able to view it unless you put it in" \
+	      "~/Library/Documentation/Help or install it in your application" \
+	      "bundle."
+
+.PHONY: devhelp
+devhelp:
+	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
+	@echo
+	@echo "Build finished."
+	@echo "To view the help file:"
+	@echo "# mkdir -p $$HOME/.local/share/devhelp/chess_py"
+	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/chess_py"
+	@echo "# devhelp"
+
+.PHONY: epub
+epub:
+	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
+	@echo
+	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."
+
+.PHONY: epub3
+epub3:
+	$(SPHINXBUILD) -b epub3 $(ALLSPHINXOPTS) $(BUILDDIR)/epub3
+	@echo
+	@echo "Build finished. The epub3 file is in $(BUILDDIR)/epub3."
+
+.PHONY: latex
+latex:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo
+	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
+	@echo "Run \`make' in that directory to run these through (pdf)latex" \
+	      "(use \`make latexpdf' here to do that automatically)."
+
+.PHONY: latexpdf
+latexpdf:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through pdflatex..."
+	$(MAKE) -C $(BUILDDIR)/latex all-pdf
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+.PHONY: latexpdfja
+latexpdfja:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through platex and dvipdfmx..."
+	$(MAKE) -C $(BUILDDIR)/latex all-pdf-ja
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+.PHONY: text
+text:
+	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
+	@echo
+	@echo "Build finished. The text files are in $(BUILDDIR)/text."
+
+.PHONY: man
+man:
+	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
+	@echo
+	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."
+
+.PHONY: texinfo
+texinfo:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo
+	@echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
+	@echo "Run \`make' in that directory to run these through makeinfo" \
+	      "(use \`make info' here to do that automatically)."
+
+.PHONY: info
+info:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo "Running Texinfo files through makeinfo..."
+	make -C $(BUILDDIR)/texinfo info
+	@echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."
+
+.PHONY: gettext
+gettext:
+	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
+	@echo
+	@echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."
+
+.PHONY: changes
+changes:
+	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
+	@echo
+	@echo "The overview file is in $(BUILDDIR)/changes."
+
+.PHONY: linkcheck
+linkcheck:
+	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
+	@echo
+	@echo "Link check complete; look for any errors in the above output " \
+	      "or in $(BUILDDIR)/linkcheck/output.txt."
+
+.PHONY: doctest
+doctest:
+	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
+	@echo "Testing of doctests in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/doctest/output.txt."
+
+.PHONY: coverage
+coverage:
+	$(SPHINXBUILD) -b coverage $(ALLSPHINXOPTS) $(BUILDDIR)/coverage
+	@echo "Testing of coverage in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/coverage/python.txt."
+
+.PHONY: xml
+xml:
+	$(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml
+	@echo
+	@echo "Build finished. The XML files are in $(BUILDDIR)/xml."
+
+.PHONY: pseudoxml
+pseudoxml:
+	$(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml
+	@echo
+	@echo "Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml."
+
+.PHONY: dummy
+dummy:
+	$(SPHINXBUILD) -b dummy $(ALLSPHINXOPTS) $(BUILDDIR)/dummy
+	@echo
+	@echo "Build finished. Dummy builder generates no files."
Index: docs/chess_py.game.rst
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/chess_py.game.rst	(date 1547112767000)
+++ docs/chess_py.game.rst	(date 1547112767000)
@@ -0,0 +1,26 @@
+chess_py.game package
+=====================
+
+chess_py.game.game module
+-------------------------
+
+.. automodule:: chess_py.game.game
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.game.game_state module
+-------------------------------
+
+.. automodule:: chess_py.game.game_state
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.game.interface module
+------------------------------
+
+.. automodule:: chess_py.game.interface
+    :members:
+    :undoc-members:
+    :show-inheritance:
Index: docs/chess_py.core.algebraic.rst
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/chess_py.core.algebraic.rst	(date 1547112767000)
+++ docs/chess_py.core.algebraic.rst	(date 1547112767000)
@@ -0,0 +1,34 @@
+chess_py.core.algebraic package
+===============================
+
+chess_py.core.algebraic.converter module
+----------------------------------------
+
+.. automodule:: chess_py.core.algebraic.converter
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.core.algebraic.location module
+---------------------------------------
+
+.. automodule:: chess_py.core.algebraic.location
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.core.algebraic.move module
+-----------------------------------
+
+.. automodule:: chess_py.core.algebraic.move
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.core.algebraic.notation_const module
+---------------------------------------------
+
+.. automodule:: chess_py.core.algebraic.notation_const
+    :members:
+    :undoc-members:
+    :show-inheritance:
Index: docs/index.rst
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/index.rst	(date 1547112767000)
+++ docs/index.rst	(date 1547112767000)
@@ -0,0 +1,27 @@
+.. chess_py documentation master file, created by
+   sphinx-quickstart on Sat Sep 17 16:32:26 2016.
+   You can adapt this file completely to your liking, but it should at least
+   contain the root `toctree` directive.
+
+Welcome to chess_py's documentation!
+====================================
+
+:author: Aubhro Sengupta
+:project:    https://github.com/LordDarkula/chess_py
+:PyGotham Talk:   https://2016.pygotham.org/talks/324/abstractions-and-building/
+
+Contents:
+
+.. toctree::
+   :maxdepth: 4
+
+   chess_py
+
+
+Indices and tables
+==================
+
+* :ref:`genindex`
+* :ref:`modindex`
+* :ref:`search`
+
Index: docs/chess_py.pieces.rst
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/chess_py.pieces.rst	(date 1547112767000)
+++ docs/chess_py.pieces.rst	(date 1547112767000)
@@ -0,0 +1,67 @@
+chess_py.pieces package
+=======================
+
+chess_py.pieces.bishop module
+-----------------------------
+
+.. automodule:: chess_py.pieces.bishop
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.pieces.king module
+---------------------------
+
+.. automodule:: chess_py.pieces.king
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.pieces.knight module
+-----------------------------
+
+.. automodule:: chess_py.pieces.knight
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.pieces.pawn module
+---------------------------
+
+.. automodule:: chess_py.pieces.pawn
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.pieces.piece module
+----------------------------
+
+.. automodule:: chess_py.pieces.piece
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.pieces.piece_const module
+----------------------------------
+
+.. automodule:: chess_py.pieces.piece_const
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.pieces.queen module
+----------------------------
+
+.. automodule:: chess_py.pieces.queen
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.pieces.rook module
+---------------------------
+
+.. automodule:: chess_py.pieces.rook
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
Index: docs/make.bat
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/make.bat	(date 1547112767000)
+++ docs/make.bat	(date 1547112767000)
@@ -0,0 +1,281 @@
+@ECHO OFF
+
+REM Command file for Sphinx documentation
+
+if "%SPHINXBUILD%" == "" (
+	set SPHINXBUILD=sphinx-build
+)
+set BUILDDIR=_build
+set ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .
+set I18NSPHINXOPTS=%SPHINXOPTS% .
+if NOT "%PAPER%" == "" (
+	set ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%
+	set I18NSPHINXOPTS=-D latex_paper_size=%PAPER% %I18NSPHINXOPTS%
+)
+
+if "%1" == "" goto help
+
+if "%1" == "help" (
+	:help
+	echo.Please use `make ^<target^>` where ^<target^> is one of
+	echo.  html       to make standalone HTML files
+	echo.  dirhtml    to make HTML files named index.html in directories
+	echo.  singlehtml to make a single large HTML file
+	echo.  pickle     to make pickle files
+	echo.  json       to make JSON files
+	echo.  htmlhelp   to make HTML files and a HTML help project
+	echo.  qthelp     to make HTML files and a qthelp project
+	echo.  devhelp    to make HTML files and a Devhelp project
+	echo.  epub       to make an epub
+	echo.  epub3      to make an epub3
+	echo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter
+	echo.  text       to make text files
+	echo.  man        to make manual pages
+	echo.  texinfo    to make Texinfo files
+	echo.  gettext    to make PO message catalogs
+	echo.  changes    to make an overview over all changed/added/deprecated items
+	echo.  xml        to make Docutils-native XML files
+	echo.  pseudoxml  to make pseudoxml-XML files for display purposes
+	echo.  linkcheck  to check all external links for integrity
+	echo.  doctest    to run all doctests embedded in the documentation if enabled
+	echo.  coverage   to run coverage check of the documentation if enabled
+	echo.  dummy      to check syntax errors of document sources
+	goto end
+)
+
+if "%1" == "clean" (
+	for /d %%i in (%BUILDDIR%\*) do rmdir /q /s %%i
+	del /q /s %BUILDDIR%\*
+	goto end
+)
+
+
+REM Check if sphinx-build is available and fallback to Python version if any
+%SPHINXBUILD% 1>NUL 2>NUL
+if errorlevel 9009 goto sphinx_python
+goto sphinx_ok
+
+:sphinx_python
+
+set SPHINXBUILD=python -m sphinx.__init__
+%SPHINXBUILD% 2> nul
+if errorlevel 9009 (
+	echo.
+	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
+	echo.installed, then set the SPHINXBUILD environment variable to point
+	echo.to the full path of the 'sphinx-build' executable. Alternatively you
+	echo.may add the Sphinx directory to PATH.
+	echo.
+	echo.If you don't have Sphinx installed, grab it from
+	echo.http://sphinx-doc.org/
+	exit /b 1
+)
+
+:sphinx_ok
+
+
+if "%1" == "html" (
+	%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/html.
+	goto end
+)
+
+if "%1" == "dirhtml" (
+	%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.
+	goto end
+)
+
+if "%1" == "singlehtml" (
+	%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.
+	goto end
+)
+
+if "%1" == "pickle" (
+	%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can process the pickle files.
+	goto end
+)
+
+if "%1" == "json" (
+	%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can process the JSON files.
+	goto end
+)
+
+if "%1" == "htmlhelp" (
+	%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can run HTML Help Workshop with the ^
+.hhp project file in %BUILDDIR%/htmlhelp.
+	goto end
+)
+
+if "%1" == "qthelp" (
+	%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can run "qcollectiongenerator" with the ^
+.qhcp project file in %BUILDDIR%/qthelp, like this:
+	echo.^> qcollectiongenerator %BUILDDIR%\qthelp\chess_py.qhcp
+	echo.To view the help file:
+	echo.^> assistant -collectionFile %BUILDDIR%\qthelp\chess_py.ghc
+	goto end
+)
+
+if "%1" == "devhelp" (
+	%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished.
+	goto end
+)
+
+if "%1" == "epub" (
+	%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The epub file is in %BUILDDIR%/epub.
+	goto end
+)
+
+if "%1" == "epub3" (
+	%SPHINXBUILD% -b epub3 %ALLSPHINXOPTS% %BUILDDIR%/epub3
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The epub3 file is in %BUILDDIR%/epub3.
+	goto end
+)
+
+if "%1" == "latex" (
+	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; the LaTeX files are in %BUILDDIR%/latex.
+	goto end
+)
+
+if "%1" == "latexpdf" (
+	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
+	cd %BUILDDIR%/latex
+	make all-pdf
+	cd %~dp0
+	echo.
+	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
+	goto end
+)
+
+if "%1" == "latexpdfja" (
+	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
+	cd %BUILDDIR%/latex
+	make all-pdf-ja
+	cd %~dp0
+	echo.
+	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
+	goto end
+)
+
+if "%1" == "text" (
+	%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The text files are in %BUILDDIR%/text.
+	goto end
+)
+
+if "%1" == "man" (
+	%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The manual pages are in %BUILDDIR%/man.
+	goto end
+)
+
+if "%1" == "texinfo" (
+	%SPHINXBUILD% -b texinfo %ALLSPHINXOPTS% %BUILDDIR%/texinfo
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The Texinfo files are in %BUILDDIR%/texinfo.
+	goto end
+)
+
+if "%1" == "gettext" (
+	%SPHINXBUILD% -b gettext %I18NSPHINXOPTS% %BUILDDIR%/locale
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The message catalogs are in %BUILDDIR%/locale.
+	goto end
+)
+
+if "%1" == "changes" (
+	%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.The overview file is in %BUILDDIR%/changes.
+	goto end
+)
+
+if "%1" == "linkcheck" (
+	%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Link check complete; look for any errors in the above output ^
+or in %BUILDDIR%/linkcheck/output.txt.
+	goto end
+)
+
+if "%1" == "doctest" (
+	%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Testing of doctests in the sources finished, look at the ^
+results in %BUILDDIR%/doctest/output.txt.
+	goto end
+)
+
+if "%1" == "coverage" (
+	%SPHINXBUILD% -b coverage %ALLSPHINXOPTS% %BUILDDIR%/coverage
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Testing of coverage in the sources finished, look at the ^
+results in %BUILDDIR%/coverage/python.txt.
+	goto end
+)
+
+if "%1" == "xml" (
+	%SPHINXBUILD% -b xml %ALLSPHINXOPTS% %BUILDDIR%/xml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The XML files are in %BUILDDIR%/xml.
+	goto end
+)
+
+if "%1" == "pseudoxml" (
+	%SPHINXBUILD% -b pseudoxml %ALLSPHINXOPTS% %BUILDDIR%/pseudoxml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The pseudo-XML files are in %BUILDDIR%/pseudoxml.
+	goto end
+)
+
+if "%1" == "dummy" (
+	%SPHINXBUILD% -b dummy %ALLSPHINXOPTS% %BUILDDIR%/dummy
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. Dummy builder generates no files.
+	goto end
+)
+
+:end
Index: docs/UCIprotocol.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/UCIprotocol.md	(date 1547112767000)
+++ docs/UCIprotocol.md	(date 1547112767000)
@@ -0,0 +1,498 @@
+> Written by Stefan-Meyer Kahlen. Taken from [this website](http://wbec-ridderkerk.nl/html/UCIProtocol.html)
+
+Description of the universal chess interface (UCI)    April 2004
+================================================================
+
+* The specification is independent of the operating system. For Windows,
+  the engine is a normal exe file, either a console or "real" windows application.
+
+* all communication is done via standard input and output with text commands,
+
+* The engine should boot and wait for input from the GUI,
+  the engine should wait for the "isready" or "setoption" command to set up its internal parameters
+  as the boot process should be as quick as possible.
+
+* the engine must always be able to process input from stdin, even while thinking.
+
+* all command strings the engine receives will end with '\n',
+  also all commands the GUI receives should end with '\n',
+  Note: '\n' can be 0x0c or 0x0a0c or any combination depending on your OS.
+  If you use Engine und GUI in the same OS this should be no problem if you cummunicate in text mode,
+  but be aware of this when for example running a Linux engine in a Windows GUI.
+
+* The engine will always be in forced mode which means it should never start calculating
+  or pondering without receiving a "go" command first.
+
+* Before the engine is asked to search on a position, there will always be a position command
+  to tell the engine about the current position.
+
+* by default all the opening book handling is done by the GUI,
+  but there is an option for the engine to use its own book ("OwnBook" option, see below)
+
+* if the engine or the GUI receives an unknown command or token it should just ignore it and try to
+  parse the rest of the string.
+
+* if the engine receives a command which is not supposed to come, for example "stop" when the engine is
+  not calculating, it should also just ignore it.
+  
+
+Move format:
+------------
+
+The move format is in long algebraic notation.
+A nullmove from the Engine to the GUI should be send as 0000.
+Examples:  e2e4, e7e5, e1g1 (white short castling), e7e8q (for promotion)
+
+
+
+GUI to engine:
+--------------
+
+These are all the command the engine gets from the interface.
+
+* uci
+	tell engine to use the uci (universal chess interface),
+	this will be send once as a first command after program boot
+	to tell the engine to switch to uci mode.
+	After receiving the uci command the engine must identify itself with the "id" command
+	and sent the "option" commands to tell the GUI which engine settings the engine supports if any.
+	After that the engine should sent "uciok" to acknowledge the uci mode.
+	If no uciok is sent within a certain time period, the engine task will be killed by the GUI.
+
+* debug [ on | off ]
+	switch the debug mode of the engine on and off.
+	In debug mode the engine should sent additional infos to the GUI, e.g. with the "info string" command,
+	to help debugging, e.g. the commands that the engine has received etc.
+	This mode should be switched off by default and this command can be sent
+	any time, also when the engine is thinking.
+
+* isready
+	this is used to synchronize the engine with the GUI. When the GUI has sent a command or
+	multiple commands that can take some time to complete,
+	this command can be used to wait for the engine to be ready again or
+	to ping the engine to find out if it is still alive.
+	E.g. this should be sent after setting the path to the tablebases as this can take some time.
+	This command is also required once before the engine is asked to do any search
+	to wait for the engine to finish initializing.
+	This command must always be answered with "readyok" and can be sent also when the engine is calculating
+	in which case the engine should also immediately answer with "readyok" without stopping the search.
+
+* setoption name <id> [value <x>]
+	this is sent to the engine when the user wants to change the internal parameters
+	of the engine. For the "button" type no value is needed.
+	One string will be sent for each parameter and this will only be sent when the engine is waiting.
+	The name of the option in <id> should not be case sensitive and can inludes spaces like also the value.
+	The substrings "value" and "name" should be avoided in <id> and <x> to allow unambiguous parsing,
+	for example do not use <name> = "draw value".
+	Here are some strings for the example below:
+	   "setoption name Nullmove value true\n"
+      "setoption name Selectivity value 3\n"
+	   "setoption name Style value Risky\n"
+	   "setoption name Clear Hash\n"
+	   "setoption name NalimovPath value c:\chess\tb\4;c:\chess\tb\5\n"
+
+* register
+	this is the command to try to register an engine or to tell the engine that registration
+	will be done later. This command should always be sent if the engine	has send "registration error"
+	at program startup.
+	The following tokens are allowed:
+	* later
+	   the user doesn't want to register the engine now.
+	* name <x>
+	   the engine should be registered with the name <x>
+	* code <y>
+	   the engine should be registered with the code <y>
+	Example:
+	   "register later"
+	   "register name Stefan MK code 4359874324"
+
+* ucinewgame
+   this is sent to the engine when the next search (started with "position" and "go") will be from
+   a different game. This can be a new game the engine should play or a new game it should analyse but
+   also the next position from a testsuite with positions only.
+   If the GUI hasn't sent a "ucinewgame" before the first "position" command, the engine shouldn't
+   expect any further ucinewgame commands as the GUI is probably not supporting the ucinewgame command.
+   So the engine should not rely on this command even though all new GUIs should support it.
+   As the engine's reaction to "ucinewgame" can take some time the GUI should always send "isready"
+   after "ucinewgame" to wait for the engine to finish its operation.
+   
+* position [fen <fenstring> | startpos ]  moves <move1> .... <movei>
+	set up the position described in fenstring on the internal board and
+	play the moves on the internal chess board.
+	if the game was played  from the start position the string "startpos" will be sent
+	Note: no "new" command is needed. However, if this position is from a different game than
+	the last position sent to the engine, the GUI should have sent a "ucinewgame" inbetween.
+
+* go
+	start calculating on the current position set up with the "position" command.
+	There are a number of commands that can follow this command, all will be sent in the same string.
+	If one command is not send its value should be interpreted as it would not influence the search.
+	* searchmoves <move1> .... <movei>
+		restrict search to this moves only
+		Example: After "position startpos" and "go infinite searchmoves e2e4 d2d4"
+		the engine should only search the two moves e2e4 and d2d4 in the initial position.
+	* ponder
+		start searching in pondering mode.
+		Do not exit the search in ponder mode, even if it's mate!
+		This means that the last move sent in in the position string is the ponder move.
+		The engine can do what it wants to do, but after a "ponderhit" command
+		it should execute the suggested move to ponder on. This means that the ponder move sent by
+		the GUI can be interpreted as a recommendation about which move to ponder. However, if the
+		engine decides to ponder on a different move, it should not display any mainlines as they are
+		likely to be misinterpreted by the GUI because the GUI expects the engine to ponder
+	   on the suggested move.
+	* wtime <x>
+		white has x msec left on the clock
+	* btime <x>
+		black has x msec left on the clock
+	* winc <x>
+		white increment per move in mseconds if x &gt; 0
+	* binc <x>
+		black increment per move in mseconds if x &gt; 0
+	* movestogo <x>
+      there are x moves to the next time control,
+		this will only be sent if x &gt; 0,
+		if you don't get this and get the wtime and btime it's sudden death
+	* depth <x>
+		search x plies only.
+	* nodes <x>
+	   search x nodes only,
+	* mate <x>
+		search for a mate in x moves
+	* movetime <x>
+		search exactly x mseconds
+	* infinite
+		search until the "stop" command. Do not exit the search without being told so in this mode!
+    
+* stop
+	stop calculating as soon as possible,
+	don't forget the "bestmove" and possibly the "ponder" token when finishing the search
+
+* ponderhit
+	the user has played the expected move. This will be sent if the engine was told to ponder on the same move
+	the user has played. The engine should continue searching but switch from pondering to normal search.
+
+* quit
+	quit the program as soon as possible
+
+
+Engine to GUI:
+--------------
+
+* id
+	* name <x>
+		this must be sent after receiving the "uci" command to identify the engine,
+		e.g. "id name Shredder X.Y\n"
+	* author <x>
+		this must be sent after receiving the "uci" command to identify the engine,
+		e.g. "id author Stefan MK\n"
+
+* uciok
+	Must be sent after the id and optional options to tell the GUI that the engine
+	has sent all infos and is ready in uci mode.
+
+* readyok
+	This must be sent when the engine has received an "isready" command and has
+	processed all input and is ready to accept new commands now.
+	It is usually sent after a command that can take some time to be able to wait for the engine,
+	but it can be used anytime, even when the engine is searching,
+	and must always be answered with "isready".
+
+* bestmove <move1> [ ponder <move2> ]
+	the engine has stopped searching and found the move <move> best in this position.
+	the engine can send the move it likes to ponder on. The engine must not start pondering automatically.
+	this command must always be sent if the engine stops searching, also in pondering mode if there is a
+	"stop" command, so for every "go" command a "bestmove" command is needed!
+	Directly before that the engine should send a final "info" command with the final search information,
+	the the GUI has the complete statistics about the last search.
+
+* copyprotection
+	this is needed for copyprotected engines. After the uciok command the engine can tell the GUI,
+	that it will check the copy protection now. This is done by "copyprotection checking".
+	If the check is ok the engine should sent "copyprotection ok", otherwise "copyprotection error".
+	If there is an error the engine should not function properly but should not quit alone.
+	If the engine reports "copyprotection error" the GUI should not use this engine
+	and display an error message instead!
+	The code in the engine can look like this
+      TellGUI("copyprotection checking\n");
+	   // ... check the copy protection here ...
+	   if(ok)
+	      TellGUI("copyprotection ok\n");
+      else
+         TellGUI("copyprotection error\n");
+         
+* registration
+	this is needed for engines that need a username and/or a code to function with all features.
+	Analog to the "copyprotection" command the engine can send "registration checking"
+	after the uciok command followed by either "registration ok" or "registration error".
+	Also after every attempt to register the engine it should answer with "registration checking"
+	and then either "registration ok" or "registration error".
+	In contrast to the "copyprotection" command, the GUI can use the engine after the engine has
+	reported an error, but should inform the user that the engine is not properly registered
+	and might not use all its features.
+	In addition the GUI should offer to open a dialog to
+	enable registration of the engine. To try to register an engine the GUI can send
+	the "register" command.
+	The GUI has to always answer with the "register" command	if the engine sends "registration error"
+	at engine startup (this can also be done with "register later")
+	and tell the user somehow that the engine is not registered.
+	This way the engine knows that the GUI can deal with the registration procedure and the user
+	will be informed that the engine is not properly registered.
+	      
+* info
+	the engine wants to send infos to the GUI. This should be done whenever one of the info has changed.
+	The engine can send only selected infos and multiple infos can be send with one info command,
+	e.g. "info currmove e2e4 currmovenumber 1" or
+	     "info depth 12 nodes 123456 nps 100000".
+	Also all infos belonging to the pv should be sent together
+	e.g. "info depth 2 score cp 214 time 1242 nodes 2124 nps 34928 pv e2e4 e7e5 g1f3"
+	I suggest to start sending "currmove", "currmovenumber", "currline" and "refutation" only after one second
+	to avoid too much traffic.
+	Additional info:
+	* depth <x>
+		search depth in plies
+	* seldepth <x>
+		selective search depth in plies,
+		if the engine sends seldepth there must also a "depth" be present in the same string.
+	* time <x>
+		the time searched in ms, this should be sent together with the pv.
+	* nodes <x>
+		x nodes searched, the engine should send this info regularly
+	* pv <move1> ... <movei>
+		the best line found
+	* multipv <num>
+		this for the multi pv mode.
+		for the best move/pv add "multipv 1" in the string when you send the pv.
+		in k-best mode always send all k variants in k strings together.
+	* score
+		* cp <x>
+			the score from the engine's point of view in centipawns.
+		* mate <y>
+			mate in y moves, not plies.
+			If the engine is getting mated use negativ values for y.
+		* lowerbound
+	      the score is just a lower bound.
+		* upperbound
+		   the score is just an upper bound.
+	* currmove <move>
+		currently searching this move
+	* currmovenumber <x>
+		currently searching move number x, for the first move x should be 1 not 0.
+	* hashfull <x>
+		the hash is x permill full, the engine should send this info regularly
+	* nps <x>
+		x nodes per second searched, the engine should send this info regularly
+	* tbhits <x>
+		x positions where found in the endgame table bases
+	* cpuload <x>
+		the cpu usage of the engine is x permill.
+	* string <str>
+		any string str which will be displayed be the engine,
+		if there is a string command the rest of the line will be interpreted as <str>.
+	* refutation <move1> <move2> ... <movei>
+	   move <move1> is refuted by the line <move2> ... <movei>, i can be any number &gt;= 1.
+	   Example: after move d1h5 is searched, the engine can send
+	   "info refutation d1h5 g6h5"
+	   if g6h5 is the best answer after d1h5 or if g6h5 refutes the move d1h5.
+	   if there is norefutation for d1h5 found, the engine should just send
+	   "info refutation d1h5"
+		The engine should only send this if the option "UCI_ShowRefutations" is set to true.
+	* currline <cpunr> <move1> ... <movei>
+	   this is the current line the engine is calculating. <cpunr> is the number of the cpu if
+	   the engine is running on more than one cpu. <cpunr> = 1,2,3....
+	   if the engine is just using one cpu, <cpunr> can be omitted.
+	   If <cpunr> is greater than 1, always send all k lines in k strings together.
+		The engine should only send this if the option "UCI_ShowCurrLine" is set to true.
+	
+
+* option
+	This command tells the GUI which parameters can be changed in the engine.
+	This should be sent once at engine startup after the "uci" and the "id" commands
+	if any parameter can be changed in the engine.
+	The GUI should parse this and build a dialog for the user to change the settings.
+	Note that not every option needs to appear in this dialog as some options like
+	"Ponder", "UCI_AnalyseMode", etc. are better handled elsewhere or are set automatically.
+	If the user wants to change some settings, the GUI will send a "setoption" command to the engine.
+	Note that the GUI need not send the setoption command when starting the engine for every option if
+	it doesn't want to change the default value.
+	For all allowed combinations see the example below,
+	as some combinations of this tokens don't make sense.
+	One string will be sent for each parameter.
+	* name <id>
+		The option has the name id.
+		Certain options have a fixed value for <id>, which means that the semantics of this option is fixed.
+		Usually those options should not be displayed in the normal engine options window of the GUI but
+		get a special treatment. "Pondering" for example should be set automatically when pondering is
+		enabled or disabled in the GUI options. The same for "UCI_AnalyseMode" which should also be set
+		automatically by the GUI. All those certain options have the prefix "UCI_" except for the
+		first 6 options below. If the GUI get an unknown Option with the prefix "UCI_", it should just
+		ignore it and not display it in the engine's options dialog.
+		* <id> = Hash, type is spin
+			the value in MB for memory for hash tables can be changed,
+			this should be answered with the first "setoptions" command at program boot
+			if the engine has sent the appropriate "option name Hash" command,
+			which should be supported by all engines!
+			So the engine should use a very small hash first as default.
+		* <id> = NalimovPath, type string
+			this is the path on the hard disk to the Nalimov compressed format.
+			Multiple directories can be concatenated with ";"
+		* <id> = NalimovCache, type spin
+			this is the size in MB for the cache for the nalimov table bases
+			These last two options should also be present in the initial options exchange dialog
+			when the engine is booted if the engine supports it
+		* <id> = Ponder, type check
+			this means that the engine is able to ponder.
+			The GUI will send this whenever pondering is possible or not.
+			Note: The engine should not start pondering on its own if this is enabled, this option is only
+			needed because the engine might change its time management algorithm when pondering is allowed.
+		* <id> = OwnBook, type check
+			this means that the engine has its own book which is accessed by the engine itself.
+			if this is set, the engine takes care of the opening book and the GUI will never
+			execute a move out of its book for the engine. If this is set to false by the GUI,
+			the engine should not access its own book.
+		* <id> = MultiPV, type spin
+			the engine supports multi best line or k-best mode. the default value is 1
+		* <id> = UCI_ShowCurrLine, type check, should be false by default,
+			the engine can show the current line it is calculating. see "info currline" above.
+		* <id> = UCI_ShowRefutations, type check, should be false by default,
+			the engine can show a move and its refutation in a line. see "info refutations" above.
+		* <id> = UCI_LimitStrength, type check, should be false by default,
+			The engine is able to limit its strength to a specific Elo number,
+		   This should always be implemented together with "UCI_Elo".
+		* <id> = UCI_Elo, type spin
+			The engine can limit its strength in Elo within this interval.
+			If UCI_LimitStrength is set to false, this value should be ignored.
+			If UCI_LimitStrength is set to true, the engine should play with this specific strength.
+		   This should always be implemented together with "UCI_LimitStrength".
+		* <id> = UCI_AnalyseMode, type check
+		   The engine wants to behave differently when analysing or playing a game.
+		   For example when playing it can use some kind of learning.
+		   This is set to false if the engine is playing a game, otherwise it is true.
+		 * <id> = UCI_Opponent, type string
+		   With this command the GUI can send the name, title, elo and if the engine is playing a human
+		   or computer to the engine.
+		   The format of the string has to be [GM|IM|FM|WGM|WIM|none] [<elo>|none] [computer|human] <name>
+		   Example:
+		   "setoption name UCI_Opponent value GM 2800 human Gary Kasparow"
+		   "setoption name UCI_Opponent value none none computer Shredder"
+		   		   
+		
+	* type <t>
+		The option has type t.
+		There are 5 different types of options the engine can send
+		* check
+			a checkbox that can either be true or false
+		* spin
+			a spin wheel that can be an integer in a certain range
+		* combo
+			a combo box that can have different predefined strings as a value
+		* button
+			a button that can be pressed to send a command to the engine
+		* string
+			a text field that has a string as a value,
+			an empty string has the value "<empty>"
+	* default <x>
+		the default value of this parameter is x
+	* min <x>
+		the minimum value of this parameter is x
+	* max <x>
+		the maximum value of this parameter is x
+	* var <x>
+		a predefined value of this parameter is x
+	Example:
+    Here are 5 strings for each of the 5 possible types of options
+	   "option name Nullmove type check default true\n"
+      "option name Selectivity type spin default 2 min 0 max 4\n"
+	   "option name Style type combo default Normal var Solid var Normal var Risky\n"
+	   "option name NalimovPath type string default c:\\n"
+	   "option name Clear Hash type button\n"
+
+
+
+Example:
+--------
+
+This is how the communication when the engine boots can look like:
+
+GUI     engine
+``` java
+// tell the engine to switch to UCI mode
+uci
+
+// engine identify  
+      id name Shredder
+		id author Stefan MK
+
+// engine sends the options it can change
+// the engine can change the hash size from 1 to 128 MB
+		option name Hash type spin default 1 min 1 max 128
+
+// the engine supports Nalimov endgame tablebases
+		option name NalimovPath type string default <empty>
+		option name NalimovCache type spin default 1 min 1 max 32
+
+// the engine can switch off Nullmove and set the playing style
+	   option name Nullmove type check default true
+  		option name Style type combo default Normal var Solid var Normal var Risky
+
+// the engine has sent all parameters and is ready
+		uciok
+
+// Note: here the GUI can already send a "quit" command if it just wants to find out
+//       details about the engine, so the engine should not initialize its internal
+//       parameters before here.
+// now the GUI sets some values in the engine
+// set hash to 32 MB
+setoption name Hash value 32
+
+// init tbs
+setoption name NalimovCache value 1
+setoption name NalimovPath value d:\tb;c\tb
+
+// waiting for the engine to finish initializing
+// this command and the answer is required here!
+isready
+
+// engine has finished setting up the internal values
+		readyok
+
+// now we are ready to go
+
+// if the GUI is supporting it, tell the engine that is is
+// searching on a game that is hasn't searched on before
+ucinewgame
+
+// if the engine supports the "UCI_AnalyseMode" option and the next search is supposted to
+// be an analysis, the GUI should set "UCI_AnalyseMode" to true if it is currently
+// set to false with this engine
+setoption name UCI_AnalyseMode value true
+
+// tell the engine to search infinite from the start position after 1.e4 e5
+position startpos moves e2e4 e7e5
+go infinite
+
+// the engine starts sending infos about the search to the GUI
+// (only some examples are given)
+
+
+		info depth 1 seldepth 0
+		info score cp 13  depth 1 nodes 13 time 15 pv f1b5 
+		info depth 2 seldepth 2
+		info nps 15937
+		info score cp 14  depth 2 nodes 255 time 15 pv f1c4 f8c5 
+		info depth 2 seldepth 7 nodes 255
+		info depth 3 seldepth 7
+		info nps 26437
+		info score cp 20  depth 3 nodes 423 time 15 pv f1c4 g8f6 b1c3 
+		info nps 41562
+		....
+
+
+// here the user has seen enough and asks to stop the searching
+stop
+
+// the engine has finished searching and is sending the bestmove command
+// which is needed for every "go" command sent to tell the GUI
+// that the engine is ready again
+		bestmove g1f3 ponder d8f6
+```
Index: docs/chess_py.core.rst
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/chess_py.core.rst	(date 1547112767000)
+++ docs/chess_py.core.rst	(date 1547112767000)
@@ -0,0 +1,26 @@
+chess_py.core package
+=====================
+
+Subpackages
+-----------
+
+.. toctree::
+
+    chess_py.core.algebraic
+
+chess_py.core.board module
+--------------------------
+
+.. automodule:: chess_py.core.board
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.core.color module
+--------------------------
+
+.. automodule:: chess_py.core.color
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
Index: docs/chess_py.players.rst
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/chess_py.players.rst	(date 1547112767000)
+++ docs/chess_py.players.rst	(date 1547112767000)
@@ -0,0 +1,19 @@
+chess_py.players package
+========================
+
+chess_py.players.human module
+-----------------------------
+
+.. automodule:: chess_py.players.human
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
+chess_py.players.player module
+------------------------------
+
+.. automodule:: chess_py.players.player
+    :members:
+    :undoc-members:
+    :show-inheritance:
+
diff --git Graphics/test.jpg Graphics/test.jpg
deleted file mode 100644
index ce2252da664ca38959de078ac5c4339c87c3f58b..0000000000000000000000000000000000000000
GIT binary patch
literal 0
Hc$@<O00001

diff --git images/board.png images/board.png
deleted file mode 100644
index 1608a524c7ba45bf0d6a0dcde6d25c5487f2fe8f..0000000000000000000000000000000000000000
GIT binary patch
literal 0
Hc$@<O00001

